This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
android/
  app/
    src/
      androidTest/
        java/
          com/
            getcapacitor/
              myapp/
                ExampleInstrumentedTest.java
      main/
        java/
          ionic/
            frontend/
              MainActivity.java
        res/
          drawable/
            ic_launcher_background.xml
          drawable-v24/
            ic_launcher_foreground.xml
          layout/
            activity_main.xml
          mipmap-anydpi-v26/
            ic_launcher_round.xml
            ic_launcher.xml
          values/
            ic_launcher_background.xml
            strings.xml
            styles.xml
          xml/
            file_paths.xml
        AndroidManifest.xml
      test/
        java/
          com/
            getcapacitor/
              myapp/
                ExampleUnitTest.java
    .gitignore
    build.gradle
    capacitor.build.gradle
    proguard-rules.pro
  gradle/
    wrapper/
      gradle-wrapper.properties
  .gitignore
  build.gradle
  capacitor.settings.gradle
  gradle.properties
  gradlew
  gradlew.bat
  settings.gradle
  variables.gradle
cypress/
  e2e/
    test.cy.ts
  fixtures/
    example.json
  support/
    commands.ts
    e2e.ts
ios/
  App/
    App/
      Assets.xcassets/
        AppIcon.appiconset/
          Contents.json
        Splash.imageset/
          Contents.json
        Contents.json
      Base.lproj/
        LaunchScreen.storyboard
        Main.storyboard
      AppDelegate.swift
      Info.plist
    App.xcodeproj/
      project.pbxproj
    App.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
    Podfile
  .gitignore
public/
  manifest.json
src/
  components/
    ExploreContainer.css
    ExploreContainer.tsx
    MarcadorView.tsx
  context/
    AuthContext.tsx
  interfaces/
    index.ts
  pages/
    css/
      CalendarView.css
      Home.css
      Login.css
      ManageCourts.css
      ManageUsers.css
      MarcadorView.css
      Profile.css
      Register.css
      Reservas.css
    CalendarView.tsx
    Home.tsx
    Login.tsx
    ManageCourts.tsx
    ManageUsers.tsx
    MarcadorControl.tsx
    MarcadorPantalla.tsx
    MarcadorView.tsx
    Profile.tsx
    Register.tsx
    Reservas.tsx
  services/
    api.service.ts
    auth.service.ts
  theme/
    variables.css
  utils/
    constants.ts
  App.test.tsx
  App.tsx
  main.tsx
  setupTests.ts
  vite-env.d.ts
.browserslistrc
.gitignore
capacitor.config.ts
cypress.config.ts
eslint.config.js
index.html
ionic.config.json
manual-programador.md
package.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/MarcadorView.tsx">
// src/components/MarcadorView.tsx
import React from 'react';

interface Props {
  estado: {
    puntos: any;
    juegos: any;
    sets: Array<any>;
    tie_break: boolean;
    terminado: boolean;
  };
}

const MarcadorView: React.FC<Props> = ({ estado }) => {
  return (
    <div>
      <h2>Marcador</h2>
      <p><strong>Set actual:</strong> A {estado.sets[estado.sets.length - 1].A} - B {estado.sets[estado.sets.length - 1].B}</p>
      <p><strong>Juegos:</strong> A {estado.juegos.A} - B {estado.juegos.B}</p>
      <p><strong>Puntos:</strong> A {estado.puntos.A} - B {estado.puntos.B}</p>
      {estado.tie_break && <p><em>En tie-break</em></p>}
      {estado.terminado && <p><strong>¡Partido Terminado!</strong></p>}
    </div>
  );
};

export default MarcadorView;
</file>

<file path="src/pages/css/MarcadorView.css">
/* Estilos para el componente MarcadorView y páginas relacionadas */

/* Estilos para el componente de visualización */
.marcador-container {
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  align-items: center;
  flex-wrap: wrap;
  padding: 2rem;
  font-size: 2rem;
}

.equipo {
  text-align: center;
  padding: 1rem 2rem;
  border-radius: 20px;
  min-width: 250px;
  background-color: #f4f4f4;
  box-shadow: 0px 2px 8px rgba(0,0,0,0.1);
}

.equipo-a {
  border: 3px solid #007bff;
}

.equipo-b {
  border: 3px solid #dc3545;
}

.separador {
  font-size: 3rem;
  font-weight: bold;
  margin: 1rem 2rem;
}

.puntos {
  font-size: 4rem;
  font-weight: bold;
  margin-top: 0.5rem;
}

.estado-info {
  width: 100%;
  text-align: center;
  font-style: italic;
  font-size: 1.5rem;
  margin-top: 1rem;
  color: orange;
}

.estado-fin {
  width: 100%;
  text-align: center;
  font-weight: bold;
  font-size: 2rem;
  margin-top: 1rem;
  color: green;
}

/* Estilos para las páginas de marcador */
.marcador-card {
  max-width: 800px;
  margin: auto;
  box-shadow: 0px 2px 12px rgba(0, 0, 0, 0.2);
  border-radius: 20px;
}

.marcador-pantalla-container {
  --background: #121212;
  color: white;
}

.marcador-pantalla {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100%;
  padding: 2rem;
  background-color: #121212;
}

/* La pantalla completa muestra un marcador más grande */
.marcador-pantalla .marcador-container {
  transform: scale(1.5);
  margin: 2rem 0;
}

.marcador-pantalla .equipo {
  background-color: #2a2a2a;
  color: white;
}

.marcador-pantalla .estado-info,
.marcador-pantalla .estado-fin {
  font-size: 2.5rem;
  color: #ffc107;
}

.marcador-pantalla .estado-fin {
  color: #28a745;
}

.cargando {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100px;
  font-size: 1.2rem;
  color: #666;
}

.error-mensaje {
  color: #dc3545;
  padding: 1rem;
  margin: 1rem 0;
  border: 1px solid #dc3545;
  border-radius: 8px;
  text-align: center;
}

.ultima-actualizacion {
  margin-top: 2rem;
  font-size: 0.9rem;
  opacity: 0.6;
  text-align: center;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .marcador-pantalla .marcador-container {
    transform: scale(1);
  }
  
  .equipo {
    min-width: 180px;
    padding: 0.8rem 1.5rem;
  }
  
  .separador {
    font-size: 2rem;
    margin: 0.8rem 1rem;
  }
  
  .puntos {
    font-size: 3rem;
  }
  
  .marcador-pantalla .estado-info,
  .marcador-pantalla .estado-fin {
    font-size: 1.8rem;
  }
}

/* Ajustes para pantallas extra pequeñas */
@media (max-width: 480px) {
  .marcador-container {
    flex-direction: column;
    padding: 1rem;
  }
  
  .equipo {
    margin-bottom: 1rem;
    min-width: 220px;
  }
  
  .separador {
    margin: 0.5rem;
  }
  
  .puntos {
    font-size: 2.5rem;
  }
}
</file>

<file path="src/pages/MarcadorControl.tsx">
import {
  IonPage, 
  IonHeader, 
  IonToolbar, 
  IonTitle, 
  IonContent,
  IonCard, 
  IonCardHeader, 
  IonCardTitle, 
  IonCardContent,
  IonButton, 
  IonGrid, 
  IonRow, 
  IonCol, 
  IonIcon, 
  IonBackButton, 
  IonButtons,
  IonLoading,
  IonToast,
  IonText
} from '@ionic/react';
import { useEffect, useState } from 'react';
import { tennisballOutline, refreshOutline, playOutline, addOutline } from 'ionicons/icons';
import axios from 'axios';
import MarcadorView from '../components/MarcadorView';
import './css/MarcadorView.css';

/**
 * Página de control del marcador.
 * Permite controlar el marcador de un partido, asignando puntos a los equipos,
 * reiniciando el partido y mostrando el marcador en pantalla completa.
 */
const MarcadorControl: React.FC = () => {
  // Estado del marcador
  const [estado, setEstado] = useState<any>(null);
  
  // Estados de UI
  const [cargando, setCargando] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [showToast, setShowToast] = useState<boolean>(false);
  const [toastMessage, setToastMessage] = useState<string>('');
  const [toastColor, setToastColor] = useState<string>('success');

  /**
   * Obtiene el estado actual del marcador desde el servidor
   */
  const fetchMarcador = async () => {
    try {
      setCargando(true);
      setError(null);
      const res = await axios.get('/marcador');
      setEstado(res.data);
    } catch (err) {
      console.error('Error al obtener el marcador', err);
      setError('Error al obtener datos del marcador. Por favor, inténtalo de nuevo.');
    } finally {
      setCargando(false);
    }
  };

  /**
   * Asigna un punto al equipo especificado
   * @param equipo - Equipo al que asignar el punto ('A' o 'B')
   */
  const anotarPunto = async (equipo: 'A' | 'B') => {
    try {
      await axios.post('/marcador/punto', { equipo });
      fetchMarcador();
      mostrarToast(`Punto anotado para el equipo ${equipo}`, 'success');
    } catch (err) {
      console.error(`Error al anotar punto para equipo ${equipo}`, err);
      setError(`Error al anotar punto para equipo ${equipo}. Por favor, inténtalo de nuevo.`);
      mostrarToast(`Error al anotar punto para equipo ${equipo}`, 'danger');
    }
  };

  /**
   * Reinicia el marcador del partido
   */
  const reiniciar = async () => {
    try {
      await axios.post('/marcador/reset');
      fetchMarcador();
      mostrarToast('Marcador reiniciado correctamente', 'success');
    } catch (err) {
      console.error('Error al reiniciar el marcador', err);
      setError('Error al reiniciar el marcador. Por favor, inténtalo de nuevo.');
      mostrarToast('Error al reiniciar el marcador', 'danger');
    }
  };

  /**
   * Abre una ventana con el marcador en pantalla completa
   */
  const abrirMarcador = () => {
    window.open('/marcador-pantalla', '_blank', 'width=1000,height=700');
  };

  /**
   * Muestra un mensaje toast
   */
  const mostrarToast = (mensaje: string, color: string = 'success') => {
    setToastMessage(mensaje);
    setToastColor(color);
    setShowToast(true);
  };

  // Efecto para cargar el marcador al iniciar y cada 2 segundos
  useEffect(() => {
    fetchMarcador();
    const interval = setInterval(fetchMarcador, 2000);
    return () => clearInterval(interval);
  }, []);

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/home" />
          </IonButtons>
          <IonTitle>Gestión de Marcador</IonTitle>
        </IonToolbar>
      </IonHeader>
      
      <IonContent className="ion-padding">
        <IonCard className="marcador-card">
          <IonCardHeader>
            <IonCardTitle>Marcador Pista 1</IonCardTitle>
          </IonCardHeader>
          
          <IonCardContent>
            {/* Mostrar indicador de carga si está cargando y no hay datos */}
            {cargando && !estado && (
              <div className="cargando">
                <IonText color="medium">Cargando marcador...</IonText>
              </div>
            )}
            
            {/* Mostrar mensaje de error si hay alguno */}
            {error && (
              <div className="error-mensaje">
                <IonText color="danger">{error}</IonText>
              </div>
            )}
            
            {/* Mostrar el marcador si hay datos */}
            {estado && <MarcadorView estado={estado} />}
            
            {/* Controles del marcador */}
            <IonGrid className="ion-padding-top">
              <IonRow>
                <IonCol>
                  <IonButton 
                    expand="block" 
                    color="primary" 
                    size="large"
                    disabled={!estado || estado.terminado} 
                    onClick={() => anotarPunto("A")}
                  >
                    <IonIcon slot="start" icon={addOutline} />
                    Punto Equipo A
                  </IonButton>
                </IonCol>
                <IonCol>
                  <IonButton 
                    expand="block" 
                    color="danger" 
                    size="large"
                    disabled={!estado || estado.terminado}
                    onClick={() => anotarPunto("B")}
                  >
                    <IonIcon slot="start" icon={addOutline} />
                    Punto Equipo B
                  </IonButton>
                </IonCol>
              </IonRow>
              
              <IonRow className="ion-padding-top">
                <IonCol>
                  <IonButton expand="block" color="medium" onClick={reiniciar}>
                    <IonIcon slot="start" icon={refreshOutline} />
                    Reiniciar Partido
                  </IonButton>
                </IonCol>
                <IonCol>
                  <IonButton expand="block" color="success" onClick={abrirMarcador}>
                    <IonIcon slot="start" icon={playOutline} />
                    Mostrar en Pantalla
                  </IonButton>
                </IonCol>
              </IonRow>
            </IonGrid>
          </IonCardContent>
        </IonCard>
        
        {/* Loading y toast para notificaciones */}
        <IonLoading isOpen={cargando && !estado} message="Cargando marcador..." />
        
        <IonToast
          isOpen={showToast}
          onDidDismiss={() => setShowToast(false)}
          message={toastMessage}
          duration={2000}
          position="bottom"
          color={toastColor}
        />
      </IonContent>
    </IonPage>
  );
};

export default MarcadorControl;
</file>

<file path="src/pages/MarcadorPantalla.tsx">
import { 
  IonPage, 
  IonContent, 
  IonHeader, 
  IonToolbar, 
  IonTitle,
  IonLoading,
  IonText,
  IonButtons,
  IonButton,
  IonIcon
} from '@ionic/react';
import { useEffect, useState } from 'react';
import { refreshOutline, closeOutline } from 'ionicons/icons';
import axios from 'axios';

// IMPORTANTE: Usa la ruta explícita y absoluta para evitar confusiones
import MarcadorView from '../pages/MarcadorView';
import './css/MarcadorView.css';

/**
 * Página de visualización del marcador en pantalla completa.
 * Esta página está optimizada para ser mostrada en una pantalla secundaria
 * o en modo kiosko para que los jugadores y espectadores puedan ver el marcador.
 */
const MarcadorPantalla: React.FC = () => {
  // Estado del marcador
  const [estado, setEstado] = useState<any>(null);
  
  // Estados de UI
  const [cargando, setCargando] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date());

  /**
   * Obtiene el estado actual del marcador desde el servidor
   */
  const fetchEstado = async () => {
    try {
      setCargando(true);
      setError(null);
      const res = await axios.get('/marcador');
      setEstado(res.data);
      setLastUpdate(new Date());
    } catch (err) {
      console.error('Error al obtener el marcador', err);
      setError('Error al obtener datos del marcador');
    } finally {
      setCargando(false);
    }
  };

  /**
   * Función para refrescar manualmente el marcador
   */
  const refreshMarcador = () => {
    fetchEstado();
  };

  /**
   * Función para cerrar la ventana (útil cuando se abre en ventana popup)
   */
  const closeWindow = () => {
    window.close();
  };

  // Efecto para cargar el marcador al iniciar y cada 2 segundos
  useEffect(() => {
    fetchEstado();
    const interval = setInterval(fetchEstado, 2000);
    return () => clearInterval(interval);
  }, []);

  // Efecto para configurar el comportamiento de pantalla completa
  useEffect(() => {
    // Configurar pantalla completa para mejor visualización
    document.documentElement.style.overflow = 'hidden';
    document.body.style.backgroundColor = '#121212';
    
    return () => {
      document.documentElement.style.overflow = '';
      document.body.style.backgroundColor = '';
    };
  }, []);

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonTitle>Marcador - Pista 1</IonTitle>
          <IonButtons slot="end">
            <IonButton onClick={refreshMarcador}>
              <IonIcon slot="icon-only" icon={refreshOutline} />
            </IonButton>
            <IonButton onClick={closeWindow}>
              <IonIcon slot="icon-only" icon={closeOutline} />
            </IonButton>
          </IonButtons>
        </IonToolbar>
      </IonHeader>
      
      <IonContent className="marcador-pantalla-container" fullscreen>
        <div className="marcador-pantalla">
          {/* Mostrar indicador de carga si está cargando y no hay datos */}
          {cargando && !estado && (
            <div className="cargando">
              <IonText color="medium">Cargando marcador...</IonText>
            </div>
          )}
          
          {/* Mostrar mensaje de error si hay alguno */}
          {error && (
            <div className="error-mensaje">
              <IonText color="danger">{error}</IonText>
              <IonButton 
                size="small" 
                fill="clear" 
                color="primary" 
                onClick={refreshMarcador}
              >
                <IonIcon slot="start" icon={refreshOutline} />
                Reintentar
              </IonButton>
            </div>
          )}
          
          {/* Mostrar el marcador si hay datos */}
          {estado && <MarcadorView estado={estado} estilo="completo" />}
          
          {/* Información de última actualización */}
          {estado && (
            <div className="ultima-actualizacion">
              <IonText color="medium">
                Última actualización: {lastUpdate.toLocaleTimeString()}
              </IonText>
            </div>
          )}
        </div>
      </IonContent>
    </IonPage>
  );
};

export default MarcadorPantalla;
</file>

<file path="src/pages/MarcadorView.tsx">
// src/components/MarcadorView.tsx
import React from 'react';

interface Props {
  estado: {
    puntos: any;
    juegos: any;
    sets: Array<any>;
    tie_break: boolean;
    terminado: boolean;
  };
  estilo?: 'simple' | 'completo';
}

const MarcadorView: React.FC<Props> = ({ estado, estilo = 'simple' }) => {
  // Verificación de datos completa con valores por defecto
  const setActual = estado && estado.sets && estado.sets.length > 0
    ? estado.sets[estado.sets.length - 1]
    : { A: 0, B: 0 };
  
  const juegos = estado && estado.juegos ? estado.juegos : { A: 0, B: 0 };
  const puntos = estado && estado.puntos ? estado.puntos : { A: 0, B: 0 };
  const enTieBreak = estado && estado.tie_break ? estado.tie_break : false;
  const partidoTerminado = estado && estado.terminado ? estado.terminado : false;

  // Si no hay datos de estado, mostrar un estado de carga
  if (!estado) {
    return (
      <div>
        <h2>Marcador</h2>
        <p>Cargando datos del marcador...</p>
      </div>
    );
  }

  // Si estilo es completo, usar el diseño avanzado con clases CSS
  if (estilo === 'completo') {
    return (
      <div className="marcador-container">
        <div className="equipo equipo-a">
          <h2>Equipo A</h2>
          <p>Sets: {setActual.A}</p>
          <p>Juegos: {juegos.A}</p>
          <p className="puntos">{puntos.A}</p>
        </div>
        <div className="separador">VS</div>
        <div className="equipo equipo-b">
          <h2>Equipo B</h2>
          <p>Sets: {setActual.B}</p>
          <p>Juegos: {juegos.B}</p>
          <p className="puntos">{puntos.B}</p>
        </div>
        {enTieBreak && <p className="estado-info">En Tie-Break</p>}
        {partidoTerminado && <p className="estado-fin">¡Partido Terminado!</p>}
      </div>
    );
  }

  // Diseño simple (por defecto)
  return (
    <div>
      <h2>Marcador</h2>
      <p><strong>Set actual:</strong> A {setActual.A} - B {setActual.B}</p>
      <p><strong>Juegos:</strong> A {juegos.A} - B {juegos.B}</p>
      <p><strong>Puntos:</strong> A {puntos.A} - B {puntos.B}</p>
      {enTieBreak && <p><em>En tie-break</em></p>}
      {partidoTerminado && <p><strong>¡Partido Terminado!</strong></p>}
    </div>
  );
};

export default MarcadorView;
</file>

<file path="android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}
</file>

<file path="android/app/src/main/java/ionic/frontend/MainActivity.java">
package ionic.frontend;

import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {}
</file>

<file path="android/app/src/main/res/drawable/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillColor="#26A69A"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
</vector>
</file>

<file path="android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1" />
</vector>
</file>

<file path="android/app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/values/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>
</file>

<file path="android/app/src/main/res/values/strings.xml">
<?xml version='1.0' encoding='utf-8'?>
<resources>
    <string name="app_name">frontend</string>
    <string name="title_activity_main">frontend</string>
    <string name="package_name">ionic.frontend</string>
    <string name="custom_url_scheme">ionic.frontend</string>
</resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:background">@null</item>
    </style>


    <style name="AppTheme.NoActionBarLaunch" parent="Theme.SplashScreen">
        <item name="android:background">@drawable/splash</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/xml/file_paths.xml">
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="." />
    <cache-path name="my_cache_images" path="." />
</paths>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|smallestScreenSize|screenLayout|uiMode|navigation"
            android:name=".MainActivity"
            android:label="@string/title_activity_main"
            android:theme="@style/AppTheme.NoActionBarLaunch"
            android:launchMode="singleTask"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths"></meta-data>
        </provider>
    </application>

    <!-- Permissions -->

    <uses-permission android:name="android.permission.INTERNET" />
</manifest>
</file>

<file path="android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="android/app/.gitignore">
/build/*
!/build/.npmkeep
</file>

<file path="android/app/build.gradle">
apply plugin: 'com.android.application'

android {
    namespace "ionic.frontend"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "ionic.frontend"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir, modified to accommodate modern web apps.
             // Default: https://android.googlesource.com/platform/frameworks/base/+/282e181b58cf72b6ca770dc7ca5f91f135444502/tools/aapt/AaptAssets.cpp#61
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}
</file>

<file path="android/app/capacitor.build.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_21
      targetCompatibility JavaVersion.VERSION_21
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-app')
    implementation project(':capacitor-haptics')
    implementation project(':capacitor-keyboard')
    implementation project(':capacitor-status-bar')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
</file>

<file path="android/app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="android/.gitignore">
# Using Android gitignore template: https://github.com/github/gitignore/blob/HEAD/Android.gitignore

# Built application files
*.apk
*.aar
*.ap_
*.aab

# Files for the ART/Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/
out/
#  Uncomment the following line in case you need and you don't have the release build type files in your app
# release/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

# Android Studio captures folder
captures/

# IntelliJ
*.iml
.idea/workspace.xml
.idea/tasks.xml
.idea/gradle.xml
.idea/assetWizardSettings.xml
.idea/dictionaries
.idea/libraries
# Android Studio 3 in .gitignore file.
.idea/caches
.idea/modules.xml
# Comment next line if keeping position of elements in Navigation Editor is relevant for you
.idea/navEditor.xml

# Keystore files
# Uncomment the following lines if you do not want to check your keystore files in.
#*.jks
#*.keystore

# External native build folder generated in Android Studio 2.2 and later
.externalNativeBuild
.cxx/

# Google Services (e.g. APIs or Firebase)
# google-services.json

# Freeline
freeline.py
freeline/
freeline_project_description.json

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
fastlane/readme.md

# Version control
vcs.xml

# lint
lint/intermediates/
lint/generated/
lint/outputs/
lint/tmp/
# lint/reports/

# Android Profiling
*.hprof

# Cordova plugins for Capacitor
capacitor-cordova-android-plugins

# Copied web assets
app/src/main/assets/public

# Generated Config files
app/src/main/assets/capacitor.config.json
app/src/main/assets/capacitor.plugins.json
app/src/main/res/xml/config.xml
</file>

<file path="android/build.gradle">
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.7.2'
        classpath 'com.google.gms:google-services:4.4.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="android/capacitor.settings.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-app'
project(':capacitor-app').projectDir = new File('../node_modules/@capacitor/app/android')

include ':capacitor-haptics'
project(':capacitor-haptics').projectDir = new File('../node_modules/@capacitor/haptics/android')

include ':capacitor-keyboard'
project(':capacitor-keyboard').projectDir = new File('../node_modules/@capacitor/keyboard/android')

include ':capacitor-status-bar'
project(':capacitor-status-bar').projectDir = new File('../node_modules/@capacitor/status-bar/android')
</file>

<file path="android/gradle.properties">
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
</file>

<file path="android/gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="android/settings.gradle">
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'
</file>

<file path="android/variables.gradle">
ext {
    minSdkVersion = 23
    compileSdkVersion = 35
    targetSdkVersion = 35
    androidxActivityVersion = '1.9.2'
    androidxAppCompatVersion = '1.7.0'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.15.0'
    androidxFragmentVersion = '1.8.4'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.12.1'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.2.1'
    androidxEspressoCoreVersion = '3.6.1'
    cordovaAndroidVersion = '10.1.1'
}
</file>

<file path="cypress/e2e/test.cy.ts">
describe('My First Test', () => {
  it('Visits the app root url', () => {
    cy.visit('/')
    cy.contains('#container', 'Ready to create an app?')
  })
})
</file>

<file path="cypress/fixtures/example.json">
{
  "name": "Using fixtures to represent data",
  "email": "hello@cypress.io",
  "body": "Fixtures are a great way to mock data for responses to routes"
}
</file>

<file path="cypress/support/commands.ts">
/// <reference types="cypress" />
// ***********************************************
// This example commands.ts shows you how to
// create various custom commands and overwrite
// existing commands.
//
// For more comprehensive examples of custom
// commands please read more here:
// https://on.cypress.io/custom-commands
// ***********************************************
//
//
// -- This is a parent command --
// Cypress.Commands.add('login', (email, password) => { ... })
//
//
// -- This is a child command --
// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })
//
//
// -- This is a dual command --
// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) => { ... })
//
//
// -- This will overwrite an existing command --
// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })
//
// declare global {
//   namespace Cypress {
//     interface Chainable {
//       login(email: string, password: string): Chainable<void>
//       drag(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       dismiss(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       visit(originalFn: CommandOriginalFn, url: string, options: Partial<VisitOptions>): Chainable<Element>
//     }
//   }
// }
</file>

<file path="cypress/support/e2e.ts">
// ***********************************************************
// This example support/e2e.ts is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************

// Import commands.js using ES2015 syntax:
import './commands'

// Alternatively you can use CommonJS syntax:
// require('./commands')
</file>

<file path="ios/App/App/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "filename" : "AppIcon-512@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="ios/App/App/Assets.xcassets/Splash.imageset/Contents.json">
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "splash-2732x2732-2.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "splash-2732x2732-1.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "splash-2732x2732.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="ios/App/App/Assets.xcassets/Contents.json">
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="ios/App/App/Base.lproj/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="17132" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina4_7" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="17105"/>
        <capability name="System colors in document resources" minToolsVersion="11.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <imageView key="view" userInteractionEnabled="NO" contentMode="scaleAspectFill" horizontalHuggingPriority="251" verticalHuggingPriority="251" image="Splash" id="snD-IY-ifK">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask"/>
                        <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                    </imageView>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="Splash" width="1366" height="1366"/>
        <systemColor name="systemBackgroundColor">
            <color white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
        </systemColor>
    </resources>
</document>
</file>

<file path="ios/App/App/Base.lproj/Main.storyboard">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="14111" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" colorMatched="YES" initialViewController="BYZ-38-t0r">
    <device id="retina4_7" orientation="portrait">
        <adaptation id="fullscreen"/>
    </device>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="14088"/>
    </dependencies>
    <scenes>
        <!--Bridge View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="CAPBridgeViewController" customModule="Capacitor" sceneMemberID="viewController"/>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>
</file>

<file path="ios/App/App/AppDelegate.swift">
import UIKit
import Capacitor

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    func applicationWillResignActive(_ application: UIApplication) {
        // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.
    }

    func applicationDidEnterBackground(_ application: UIApplication) {
        // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
    }

    func applicationWillEnterForeground(_ application: UIApplication) {
        // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.
    }

    func applicationDidBecomeActive(_ application: UIApplication) {
        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
    }

    func applicationWillTerminate(_ application: UIApplication) {
        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
    }

    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
        // Called when the app was launched with a url. Feel free to add additional processing here,
        // but if you want the App API to support tracking app url opens, make sure to keep this call
        return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
    }

    func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
        // Called when the app was launched with an activity, including Universal Links.
        // Feel free to add additional processing here, but if you want the App API to support
        // tracking app url opens, make sure to keep this call
        return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
    }

}
</file>

<file path="ios/App/App/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleDisplayName</key>
        <string>frontend</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(MARKETING_VERSION)</string>
	<key>CFBundleVersion</key>
	<string>$(CURRENT_PROJECT_VERSION)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<true/>
</dict>
</plist>
</file>

<file path="ios/App/App.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 48;
	objects = {

/* Begin PBXBuildFile section */
		2FAD9763203C412B000D30F8 /* config.xml in Resources */ = {isa = PBXBuildFile; fileRef = 2FAD9762203C412B000D30F8 /* config.xml */; };
		50379B232058CBB4000EE86E /* capacitor.config.json in Resources */ = {isa = PBXBuildFile; fileRef = 50379B222058CBB4000EE86E /* capacitor.config.json */; };
		504EC3081FED79650016851F /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 504EC3071FED79650016851F /* AppDelegate.swift */; };
		504EC30D1FED79650016851F /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 504EC30B1FED79650016851F /* Main.storyboard */; };
		504EC30F1FED79650016851F /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 504EC30E1FED79650016851F /* Assets.xcassets */; };
		504EC3121FED79650016851F /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 504EC3101FED79650016851F /* LaunchScreen.storyboard */; };
		50B271D11FEDC1A000F3C39B /* public in Resources */ = {isa = PBXBuildFile; fileRef = 50B271D01FEDC1A000F3C39B /* public */; };
		A084ECDBA7D38E1E42DFC39D /* Pods_App.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = AF277DCFFFF123FFC6DF26C7 /* Pods_App.framework */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		2FAD9762203C412B000D30F8 /* config.xml */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = config.xml; sourceTree = "<group>"; };
		50379B222058CBB4000EE86E /* capacitor.config.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = capacitor.config.json; sourceTree = "<group>"; };
		504EC3041FED79650016851F /* App.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = App.app; sourceTree = BUILT_PRODUCTS_DIR; };
		504EC3071FED79650016851F /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		504EC30C1FED79650016851F /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		504EC30E1FED79650016851F /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		504EC3111FED79650016851F /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		504EC3131FED79650016851F /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		50B271D01FEDC1A000F3C39B /* public */ = {isa = PBXFileReference; lastKnownFileType = folder; path = public; sourceTree = "<group>"; };
		AF277DCFFFF123FFC6DF26C7 /* Pods_App.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_App.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		AF51FD2D460BCFE21FA515B2 /* Pods-App.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-App.release.xcconfig"; path = "Pods/Target Support Files/Pods-App/Pods-App.release.xcconfig"; sourceTree = "<group>"; };
		FC68EB0AF532CFC21C3344DD /* Pods-App.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-App.debug.xcconfig"; path = "Pods/Target Support Files/Pods-App/Pods-App.debug.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		504EC3011FED79650016851F /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				A084ECDBA7D38E1E42DFC39D /* Pods_App.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		27E2DDA53C4D2A4D1A88CE4A /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				AF277DCFFFF123FFC6DF26C7 /* Pods_App.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		504EC2FB1FED79650016851F = {
			isa = PBXGroup;
			children = (
				504EC3061FED79650016851F /* App */,
				504EC3051FED79650016851F /* Products */,
				7F8756D8B27F46E3366F6CEA /* Pods */,
				27E2DDA53C4D2A4D1A88CE4A /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		504EC3051FED79650016851F /* Products */ = {
			isa = PBXGroup;
			children = (
				504EC3041FED79650016851F /* App.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		504EC3061FED79650016851F /* App */ = {
			isa = PBXGroup;
			children = (
				50379B222058CBB4000EE86E /* capacitor.config.json */,
				504EC3071FED79650016851F /* AppDelegate.swift */,
				504EC30B1FED79650016851F /* Main.storyboard */,
				504EC30E1FED79650016851F /* Assets.xcassets */,
				504EC3101FED79650016851F /* LaunchScreen.storyboard */,
				504EC3131FED79650016851F /* Info.plist */,
				2FAD9762203C412B000D30F8 /* config.xml */,
				50B271D01FEDC1A000F3C39B /* public */,
			);
			path = App;
			sourceTree = "<group>";
		};
		7F8756D8B27F46E3366F6CEA /* Pods */ = {
			isa = PBXGroup;
			children = (
				FC68EB0AF532CFC21C3344DD /* Pods-App.debug.xcconfig */,
				AF51FD2D460BCFE21FA515B2 /* Pods-App.release.xcconfig */,
			);
			name = Pods;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		504EC3031FED79650016851F /* App */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 504EC3161FED79650016851F /* Build configuration list for PBXNativeTarget "App" */;
			buildPhases = (
				6634F4EFEBD30273BCE97C65 /* [CP] Check Pods Manifest.lock */,
				504EC3001FED79650016851F /* Sources */,
				504EC3011FED79650016851F /* Frameworks */,
				504EC3021FED79650016851F /* Resources */,
				9592DBEFFC6D2A0C8D5DEB22 /* [CP] Embed Pods Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = App;
			productName = App;
			productReference = 504EC3041FED79650016851F /* App.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		504EC2FC1FED79650016851F /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 0920;
				TargetAttributes = {
					504EC3031FED79650016851F = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
					};
				};
			};
			buildConfigurationList = 504EC2FF1FED79650016851F /* Build configuration list for PBXProject "App" */;
			compatibilityVersion = "Xcode 8.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 504EC2FB1FED79650016851F;
			packageReferences = (
			);
			productRefGroup = 504EC3051FED79650016851F /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				504EC3031FED79650016851F /* App */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		504EC3021FED79650016851F /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				504EC3121FED79650016851F /* LaunchScreen.storyboard in Resources */,
				50B271D11FEDC1A000F3C39B /* public in Resources */,
				504EC30F1FED79650016851F /* Assets.xcassets in Resources */,
				50379B232058CBB4000EE86E /* capacitor.config.json in Resources */,
				504EC30D1FED79650016851F /* Main.storyboard in Resources */,
				2FAD9763203C412B000D30F8 /* config.xml in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		6634F4EFEBD30273BCE97C65 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-App-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		9592DBEFFC6D2A0C8D5DEB22 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "[CP] Embed Pods Frameworks";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-App/Pods-App-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		504EC3001FED79650016851F /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				504EC3081FED79650016851F /* AppDelegate.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXVariantGroup section */
		504EC30B1FED79650016851F /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				504EC30C1FED79650016851F /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		504EC3101FED79650016851F /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				504EC3111FED79650016851F /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		504EC3141FED79650016851F /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 14.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		504EC3151FED79650016851F /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 14.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SWIFT_OPTIMIZATION_LEVEL = "-Owholemodule";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		504EC3171FED79650016851F /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = FC68EB0AF532CFC21C3344DD /* Pods-App.debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				INFOPLIST_FILE = App/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 14.0;
				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
				MARKETING_VERSION = 1.0;
				OTHER_SWIFT_FLAGS = "$(inherited) \"-D\" \"COCOAPODS\" \"-DDEBUG\"";
				PRODUCT_BUNDLE_IDENTIFIER = ionic.frontend;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		504EC3181FED79650016851F /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = AF51FD2D460BCFE21FA515B2 /* Pods-App.release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				INFOPLIST_FILE = App/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 14.0;
				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = ionic.frontend;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		504EC2FF1FED79650016851F /* Build configuration list for PBXProject "App" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				504EC3141FED79650016851F /* Debug */,
				504EC3151FED79650016851F /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		504EC3161FED79650016851F /* Build configuration list for PBXNativeTarget "App" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				504EC3171FED79650016851F /* Debug */,
				504EC3181FED79650016851F /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 504EC2FC1FED79650016851F /* Project object */;
}
</file>

<file path="ios/App/App.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="ios/App/Podfile">
require_relative '../../node_modules/@capacitor/ios/scripts/pods_helpers'

platform :ios, '14.0'
use_frameworks!

# workaround to avoid Xcode caching of Pods that requires
# Product -> Clean Build Folder after new Cordova plugins installed
# Requires CocoaPods 1.6 or newer
install! 'cocoapods', :disable_input_output_paths => true

def capacitor_pods
  pod 'Capacitor', :path => '../../node_modules/@capacitor/ios'
  pod 'CapacitorCordova', :path => '../../node_modules/@capacitor/ios'
end

target 'App' do
  capacitor_pods
  # Add your Pods here
end

post_install do |installer|
  assertDeploymentTarget(installer)
end
</file>

<file path="ios/.gitignore">
App/build
App/Pods
App/output
App/App/public
DerivedData
xcuserdata

# Cordova plugins for Capacitor
capacitor-cordova-ios-plugins

# Generated Config files
App/App/capacitor.config.json
App/App/config.xml
</file>

<file path="public/manifest.json">
{
  "short_name": "Ionic App",
  "name": "My Ionic App",
  "icons": [
    {
      "src": "assets/icon/favicon.png",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "assets/icon/icon.png",
      "type": "image/png",
      "sizes": "512x512",
      "purpose": "maskable"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#ffffff",
  "background_color": "#ffffff"
}
</file>

<file path="src/components/ExploreContainer.css">
#container {
  text-align: center;
  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

#container strong {
  font-size: 20px;
  line-height: 26px;
}

#container p {
  font-size: 16px;
  line-height: 22px;
  color: #8c8c8c;
  margin: 0;
}

#container a {
  text-decoration: none;
}
</file>

<file path="src/components/ExploreContainer.tsx">
import './ExploreContainer.css';

interface ContainerProps { }

const ExploreContainer: React.FC<ContainerProps> = () => {
  return (
    <div id="container">
      <strong>Ready to create an app?</strong>
      <p>Start with Ionic <a target="_blank" rel="noopener noreferrer" href="https://ionicframework.com/docs/components">UI Components</a></p>
    </div>
  );
};

export default ExploreContainer;
</file>

<file path="src/theme/variables.css">
/* For information on how to create your own theme, please see:
http://ionicframework.com/docs/theming/ */

.marcador-card {
    max-width: 600px;
    margin: auto;
    box-shadow: 0px 2px 12px rgba(0, 0, 0, 0.2);
    border-radius: 20px;
  }
</file>

<file path="src/App.test.tsx">
import React from 'react';
import { render } from '@testing-library/react';
import App from './App';

test('renders without crashing', () => {
  const { baseElement } = render(<App />);
  expect(baseElement).toBeDefined();
});
</file>

<file path="src/main.tsx">
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const container = document.getElementById('root');
const root = createRoot(container!);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/setupTests.ts">
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom/extend-expect';

// Mock matchmedia
window.matchMedia = window.matchMedia || function() {
  return {
      matches: false,
      addListener: function() {},
      removeListener: function() {}
  };
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path=".browserslistrc">
Chrome >=79
ChromeAndroid >=79
Firefox >=70
Edge >=79
Safari >=14
iOS >=14
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/dist

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local
/.nx
/.nx/cache
/.vscode/*
!/.vscode/extensions.json
.idea

npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Optional eslint cache
.eslintcache
</file>

<file path="cypress.config.ts">
import { defineConfig } from "cypress";

export default defineConfig({
  e2e: {
    baseUrl: "http://localhost:5173",
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
});
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist', 'cypress.config.ts'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
      'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    },
  },
)
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Ionic App</title>
    
    <base href="/" />
    
    <meta name="color-scheme" content="light dark" />
    <meta
      name="viewport"
      content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    
    <link rel="manifest" href="/manifest.json" />
    
    <link rel="shortcut icon" type="image/png" href="/favicon.png" />
    
    <!-- add to homescreen for ios -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Ionic App" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="manual-programador.md">
# Manual del Programador: Sistema de Gestión de Clubes de Pádel

## 1. Introducción

Este manual proporciona la documentación técnica para el desarrollo y mantenimiento del sistema de gestión de clubes de pádel. La aplicación está diseñada para facilitar la administración de clubes de pádel, permitiendo a los usuarios reservar pistas, inscribirse en torneos, formar parte de grupos sociales y participar en la comunidad.

### 1.1 Visión General

El sistema está compuesto por un backend en Flask con SQLAlchemy y un frontend desarrollado con Ionic y React. La arquitectura sigue un patrón cliente-servidor con una API REST como interfaz entre ambos componentes.

### 1.2 Alcance del Sistema

El sistema incluye funcionalidades para:
- Gestión de usuarios y perfiles
- Administración de clubes y pistas
- Sistema de reservas
- Gestión de torneos y competiciones
- Funcionalidades sociales (grupos, publicaciones, seguimiento)
- Notificaciones y recordatorios

## 2. Arquitectura del Sistema

### 2.1 Diagrama de Arquitectura

```
+----------------+     +-----------------+     +------------------+
|                |     |                 |     |                  |
|  Cliente       |     |  Servidor API   |     |  Base de Datos   |
|  (Ionic/React) | <-> |  (Flask/Python) | <-> |  (PostgreSQL)    |
|                |     |                 |     |                  |
+----------------+     +-----------------+     +------------------+
```

### 2.2 Componentes Principales

#### Backend (Flask/Python)
- **Servidor API**: Implementado en Flask
- **ORM**: SQLAlchemy para mapeo y operaciones de base de datos
- **Serialización**: Marshmallow para la serialización/deserialización de datos
- **Autenticación**: Sistema JWT para la gestión de sesiones y autenticación

#### Frontend (Ionic/React)
- **Framework UI**: Ionic con React
- **Gestión de Estado**: Context API para gestión global del estado
- **Routing**: React Router para la navegación
- **HTTP Client**: Axios para las comunicaciones con el backend

## 3. Configuración del Entorno de Desarrollo

### 3.1 Requisitos Previos

- Python 3.8 o superior
- Node.js 14.x o superior
- npm 6.x o superior
- PostgreSQL o MySQL
- Git

### 3.2 Configuración del Backend

1. Clonar el repositorio:
   ```bash
   git clone https://github.com/nombre-usuario/padel-club-management.git
   cd padel-club-management/backend
   ```

2. Crear y activar un entorno virtual:
   ```bash
   python -m venv venv
   # En Windows
   venv\Scripts\activate
   # En macOS/Linux
   source venv/bin/activate
   ```

3. Instalar dependencias:
   ```bash
   pip install -r requirements.txt
   ```

4. Configurar variables de entorno:
   ```bash
   cp .env.example .env
   # Editar .env con los valores apropiados para el entorno
   ```

5. Inicializar la base de datos:
   ```bash
   flask db upgrade
   flask seed-db  # Si existe comando para poblar con datos de prueba
   ```

6. Iniciar el servidor de desarrollo:
   ```bash
   flask run
   ```

### 3.3 Configuración del Frontend

1. Navegar al directorio del frontend:
   ```bash
   cd ../frontend
   ```

2. Instalar dependencias:
   ```bash
   npm install
   ```

3. Configurar variables de entorno:
   ```bash
   cp .env.example .env
   # Editar .env con los valores apropiados para el entorno
   ```

4. Iniciar el servidor de desarrollo:
   ```bash
   npm start
   ```

## 4. Estructura del Proyecto

### 4.1 Estructura del Backend

```
backend/
├── app/
│   ├── __init__.py          # Inicialización de la aplicación
│   ├── models/              # Modelos SQLAlchemy
│   │   ├── __init__.py
│   │   ├── usuario.py       # Modelo de usuario
│   │   ├── club.py          # Modelo de club
│   │   ├── pista.py         # Modelo de pista
│   │   ├── reserva.py       # Modelo de reserva
│   │   ├── torneo.py        # Modelo de torneo
│   │   └── ...
│   ├── schemas/             # Esquemas Marshmallow
│   │   ├── __init__.py
│   │   ├── usuario.py
│   │   ├── club.py
│   │   └── ...
│   ├── routes/              # Endpoints API
│   │   ├── __init__.py
│   │   ├── auth.py          # Rutas de autenticación
│   │   ├── usuarios.py      # Rutas de usuarios
│   │   ├── clubes.py        # Rutas de clubes
│   │   └── ...
│   ├── services/            # Lógica de negocio
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── reservas.py
│   │   └── ...
│   ├── utils/               # Utilidades
│   │   ├── __init__.py
│   │   ├── decorators.py    # Decoradores personalizados
│   │   ├── validators.py    # Validadores
│   │   └── ...
│   └── config.py            # Configuración
├── migrations/              # Migraciones Alembic
├── tests/                   # Tests
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_auth.py
│   └── ...
├── .env                     # Variables de entorno (no en VCS)
├── .env.example             # Plantilla de variables de entorno
├── requirements.txt         # Dependencias
└── wsgi.py                  # Punto de entrada WSGI
```

### 4.2 Estructura del Frontend

```
frontend/
├── public/
│   ├── assets/
│   │   ├── icon/
│   │   └── ...
│   ├── index.html
│   └── manifest.json
├── src/
│   ├── components/          # Componentes React reutilizables
│   │   ├── ExploreContainer.css
│   │   └── ExploreContainer.tsx
│   ├── context/             # Contextos de React
│   │   └── AuthContext.tsx  # Contexto de autenticación
│   ├── interfaces/          # Definiciones de tipos TypeScript
│   │   └── index.ts
│   ├── pages/               # Páginas/Vistas de la aplicación
│   │   ├── css/
│   │   │   ├── Home.css
│   │   │   ├── Login.css
│   │   │   └── ...
│   │   ├── Home.tsx
│   │   ├── Login.tsx
│   │   ├── Register.tsx
│   │   ├── Profile.tsx
│   │   ├── CalendarView.tsx
│   │   ├── ManageCourts.tsx
│   │   ├── ManageUsers.tsx
│   │   ├── Reservas.tsx
│   │   └── ...
│   ├── services/            # Servicios API
│   │   ├── api.service.ts   # Cliente API base
│   │   ├── auth.service.ts  # Servicio de autenticación
│   │   └── ...
│   ├── theme/               # Estilos globales
│   │   └── variables.css
│   ├── utils/               # Utilidades
│   │   └── constants.ts     # Constantes del sistema
│   ├── App.tsx              # Componente raíz
│   ├── App.test.tsx         # Tests
│   ├── main.tsx             # Punto de entrada
│   ├── setupTests.ts        # Configuración de tests
│   └── vite-env.d.ts        # Definiciones para Vite
├── android/                 # Configuración para Android
├── ios/                     # Configuración para iOS
├── .browserslistrc
├── .gitignore
├── capacitor.config.ts      # Configuración de Capacitor
├── ionic.config.json        # Configuración de Ionic
├── package.json             # Dependencias y scripts
├── tsconfig.json            # Configuración de TypeScript
└── vite.config.ts           # Configuración de Vite
```

## 5. Modelos de Datos

Los principales modelos de datos en el sistema son:

### 5.1 Usuario

```python
class Usuario(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    apellidos = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    telefono = db.Column(db.String(20))
    id_rol = db.Column(db.Integer, db.ForeignKey('rol.id'), nullable=False)
    id_club = db.Column(db.Integer, db.ForeignKey('club.id'))
    avatar_url = db.Column(db.String(255))
    bio = db.Column(db.Text)
    activo = db.Column(db.Boolean, default=True)
    # Relaciones con otros modelos
```

### 5.2 Club

```python
class Club(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    descripcion = db.Column(db.Text)
    direccion = db.Column(db.String(255), nullable=False)
    telefono = db.Column(db.String(20))
    email = db.Column(db.String(100))
    horario_apertura = db.Column(db.String(5), nullable=False)
    horario_cierre = db.Column(db.String(5), nullable=False)
    id_administrador = db.Column(db.Integer, db.ForeignKey('usuario.id'), nullable=False)
    fecha_registro = db.Column(db.DateTime, default=datetime.utcnow)
    activo = db.Column(db.Boolean, default=True)
    imagen_url = db.Column(db.String(255))
    # Relaciones con otros modelos
```

### 5.3 Pista

```python
class Pista(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    numero = db.Column(db.Integer, nullable=False)
    id_club = db.Column(db.Integer, db.ForeignKey('club.id'), nullable=False)
    tipo = db.Column(db.String(50), nullable=False)  # Indoor, Outdoor, etc.
    estado = db.Column(db.String(50), nullable=False)  # disponible, mantenimiento, cerrada
    precio_hora = db.Column(db.Float, nullable=False)
    iluminacion = db.Column(db.Boolean, default=True)
    techada = db.Column(db.Boolean, default=False)
    # Relaciones con otros modelos
```

### 5.4 Reserva

```python
class Reserva(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    id_usuario = db.Column(db.Integer, db.ForeignKey('usuario.id'), nullable=False)
    id_pista = db.Column(db.Integer, db.ForeignKey('pista.id'), nullable=False)
    fecha = db.Column(db.Date, nullable=False)
    hora_inicio = db.Column(db.Time, nullable=False)
    hora_fin = db.Column(db.Time, nullable=False)
    precio_total = db.Column(db.Float, nullable=False)
    estado = db.Column(db.String(20), nullable=False)  # pendiente, confirmada, cancelada, completada
    notas = db.Column(db.Text)
    # Relaciones con otros modelos
```

## 6. API Endpoints

A continuación se listan los principales endpoints de la API:

### 6.1 Autenticación

- `POST /login`: Iniciar sesión
- `POST /create-user`: Registrar nuevo usuario
- `POST /logout`: Cerrar sesión
- `PUT /update-password`: Actualizar contraseña

### 6.2 Usuarios

- `GET /user/{id}`: Obtener información de un usuario
- `PUT /user/{id}`: Actualizar información de un usuario
- `GET /users`: Listar usuarios

### 6.3 Clubes

- `GET /clubs`: Listar clubes
- `GET /clubs?id_administrador={id}`: Buscar clubes por administrador
- `POST /clubs`: Crear un nuevo club
- `GET /clubs/{id}`: Obtener información de un club
- `PUT /clubs/{id}`: Actualizar información de un club
- `DELETE /clubs/{id}`: Eliminar un club

### 6.4 Pistas

- `GET /clubs/{id}/pistas`: Listar pistas de un club
- `POST /clubs/{id}/pistas`: Crear una nueva pista
- `GET /pistas/{id}`: Obtener información de una pista
- `PUT /pistas/{id}`: Actualizar información de una pista
- `DELETE /pistas/{id}`: Eliminar una pista
- `GET /pistas/{id}/disponibilidad`: Consultar disponibilidad de una pista

### 6.5 Reservas

- `GET /reservas`: Listar reservas (filtrable por usuario, club, fecha)
- `POST /crear-reserva`: Crear una reserva
- `PUT /modificar-reserva/{id}`: Modificar una reserva
- `DELETE /eliminar-reserva/{id}`: Cancelar/eliminar una reserva

### 6.6 Gestión de Membresías

- `POST /add-club-member`: Añadir un usuario como socio del club

## 7. Sistema de Autenticación

El sistema utiliza un mecanismo de autenticación basado en tokens JWT.

### 7.1 Flujo de Autenticación

1. El usuario envía credenciales (email/password) al endpoint `/login`
2. El servidor verifica las credenciales y genera un token JWT
3. El frontend almacena el token en localStorage
4. Para solicitudes autenticadas, el token se envía en el header `Authorization: Bearer {token}`
5. El servidor verifica el token en cada solicitud protegida

### 7.2 Estructura de Almacenamiento en Cliente

```typescript
// Claves de almacenamiento
export const STORAGE_KEYS = {
  AUTH_TOKEN: 'auth_token',
  USER_ID: 'user_id',
  USER_ROLE: 'user_role',
};
```

### 7.3 Contexto de Autenticación

El frontend utiliza un contexto React (`AuthContext`) para gestionar el estado de autenticación:

```typescript
// Ejemplo simplificado de AuthContext
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  login: (data: LoginRequest) => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
}
```

## 8. Gestión de Pistas y Reservas

### 8.1 Modelo de Disponibilidad

Las pistas tienen un estado que puede ser:
- `disponible`: La pista está disponible para su uso
- `mantenimiento`: La pista está en mantenimiento
- `cerrada`: La pista está cerrada

### 8.2 Flujo de Reserva

1. El usuario selecciona un club
2. Selecciona una pista
3. Selecciona una fecha
4. El sistema muestra las franjas horarias disponibles
5. El usuario selecciona una o varias franjas
6. El sistema calcula el precio total
7. El usuario confirma la reserva

### 8.3 Validación de Disponibilidad

El sistema verifica la disponibilidad en tiempo real, considerando:
- Horario de apertura y cierre del club
- Estado de la pista (solo disponibles)
- Reservas existentes para evitar duplicidades

## 9. Guía de Testing

### 9.1 Testing del Backend

Los tests del backend utilizan pytest. Para ejecutar los tests:

```bash
cd backend
pytest
```

### 9.2 Testing del Frontend

Los tests del frontend utilizan Jest y React Testing Library. Para ejecutar los tests:

```bash
cd frontend
npm test
```

### 9.3 Testing End-to-End

Los tests end-to-end utilizan Cypress. Para ejecutar los tests:

```bash
cd frontend
npm run test.e2e
```

## 10. Despliegue

### 10.1 Despliegue del Backend

1. Preparar el entorno:
   ```bash
   cd backend
   pip install gunicorn  # o uwsgi
   ```

2. Configurar variables de entorno para producción en el servidor.

3. Ejecutar migraciones:
   ```bash
   flask db upgrade
   ```

4. Iniciar el servidor:
   ```bash
   gunicorn -w 4 wsgi:app
   ```

### 10.2 Despliegue del Frontend

1. Construir la aplicación:
   ```bash
   cd frontend
   npm run build
   ```

2. Desplegar los archivos generados en el directorio `dist/` a su servidor web o servicio de hosting.

### 10.3 Despliegue con Docker

Se puede utilizar Docker para simplificar el despliegue:

```dockerfile
# Ejemplo de Dockerfile para el backend
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "-w", "4", "wsgi:app"]
```

## 11. Contribuir al Proyecto

### 11.1 Flujo de Trabajo de Git

1. Crear una rama desde `develop` para la nueva funcionalidad:
   ```bash
   git checkout develop
   git pull
   git checkout -b feature/nombre-funcionalidad
   ```

2. Desarrollar y hacer commits regulares:
   ```bash
   git add .
   git commit -m "Descripción del cambio"
   ```

3. Enviar cambios al repositorio:
   ```bash
   git push origin feature/nombre-funcionalidad
   ```

4. Crear un Pull Request a `develop`.

### 11.2 Estándares de Código

- **Backend**: Seguir PEP 8 para Python
- **Frontend**: Utilizar ESLint con la configuración del proyecto

### 11.3 Documentación

Documentar todo el código nuevo siguiendo los estándares existentes:
- **Python**: Docstrings de estilo Google
- **TypeScript/JavaScript**: JSDoc

## 12. Recursos y Referencias

### 12.1 Documentación Oficial

- [Flask](https://flask.palletsprojects.com/)
- [SQLAlchemy](https://docs.sqlalchemy.org/)
- [Marshmallow](https://marshmallow.readthedocs.io/)
- [React](https://reactjs.org/docs/getting-started.html)
- [Ionic Framework](https://ionicframework.com/docs)

### 12.2 Recursos Internos

- Repositorio de código: `https://github.com/nombre-usuario/padel-club-management`
- Documentación de API: `/api/docs` (Swagger UI)

## 13. Solución de Problemas Comunes

### 13.1 Backend

- **Problemas de migración de base de datos**:
  ```bash
  flask db stamp head  # Marcar la base de datos como actualizada
  flask db migrate     # Crear nueva migración
  flask db upgrade     # Aplicar migración
  ```

- **Resetear la base de datos de desarrollo**:
  ```bash
  flask db downgrade base  # Revertir todas las migraciones
  flask db upgrade         # Aplicar migraciones desde cero
  flask seed-db            # Repoblar con datos de prueba
  ```

### 13.2 Frontend

- **Problemas de caché**:
  ```bash
  npm cache clean --force
  rm -rf node_modules
  npm install
  ```

- **Problemas con Ionic/Capacitor**:
  ```bash
  npx cap sync  # Sincronizar cambios con proyectos nativos
  ```

---

Este manual será actualizado regularmente a medida que el proyecto evolucione. Para cualquier duda o sugerencia, contactar al equipo de desarrollo.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
/// <reference types="vitest" />

import legacy from '@vitejs/plugin-legacy'
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    react(),
    legacy()
  ],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  }
})
</file>

<file path="src/context/AuthContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { AuthContextType, LoginRequest, RegisterRequest, User } from '../interfaces';
import authService from '../services/auth.service';
import apiService from '../services/api.service';
import { API_ENDPOINTS } from '../utils/constants';

// Crear el contexto con un valor inicial
const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  error: null,
  login: async () => {},
  register: async () => {},
  logout: () => {},
  refreshUser: async () => {},
});

// Hook personalizado para usar el contexto
export const useAuth = () => useContext(AuthContext);

// Proveedor del contexto
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Verificar autenticación al cargar la aplicación
  useEffect(() => {
    const checkAuthStatus = async () => {
      try {
        setIsLoading(true);
        
        // Verificar si hay un user_id en localStorage
        const isAuth = authService.isAuthenticated();
        setIsAuthenticated(isAuth);
        
        if (isAuth) {
          const userId = authService.getUserId();
          if (userId) {
            // Cargar datos del usuario
            const userData = await authService.getCurrentUser(userId);
            setUser(userData);
          }
        }
      } catch (error: any) {
        console.error('Error al verificar autenticación:', error);
        setError(error.message);
        // Limpiar la sesión si hay un error
        authService.clearSession();
        setIsAuthenticated(false);
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };
    
    checkAuthStatus();
  }, []);

  // Función para iniciar sesión
  const login = async (credentials: LoginRequest) => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Llamar al servicio de autenticación
      const response = await authService.login(credentials);
      
      // Si la respuesta es exitosa, cargar los datos del usuario
      if (response.user_id) {
        const userData = await authService.getCurrentUser(response.user_id);
        setUser(userData);
        setIsAuthenticated(true);
      }
    } catch (error: any) {
      console.error('Error en login:', error);
      setError(error.message);
      setIsAuthenticated(false);
      setUser(null);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Función para registrar un nuevo usuario
  const register = async (userData: RegisterRequest) => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Llamar al servicio de registro
      await authService.register(userData);
      
      // No autenticamos automáticamente después del registro
      // El usuario debe iniciar sesión explícitamente
    } catch (error: any) {
      console.error('Error en registro:', error);
      setError(error.message);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Función para refrescar los datos del usuario
  const refreshUser = async () => {
    try {
      if (!isAuthenticated) return;
      
      const userId = authService.getUserId();
      if (!userId) return;
      
      setIsLoading(true);
      setError(null);
      
      // Obtener los datos actualizados del usuario
      const userData = await authService.getCurrentUser(userId);
      setUser(userData);
      
    } catch (error: any) {
      console.error('Error al refrescar datos del usuario:', error);
      setError(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Función para cerrar sesión
  const logout = async () => {
    try {
      setIsLoading(true);
      
      // Si hay un usuario logueado, enviar petición de logout al servidor
      if (user?.id) {
        await authService.logout(user.id);
      }
    } catch (error) {
      console.error('Error en logout:', error);
    } finally {
      // Limpiar el estado local
      authService.clearSession();
      setUser(null);
      setIsAuthenticated(false);
      setIsLoading(false);
    }
  };

  // Valor del contexto
  const value: AuthContextType = {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    register,
    logout,
    refreshUser,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
</file>

<file path="capacitor.config.ts">
import type { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'io.ionic.starter',
  appName: 'ionic-app-base',
  webDir: 'dist'
};

export default config;
</file>

<file path="ionic.config.json">
{
  "name": "ionic-app-base",
  "integrations": {
    "capacitor": {}
  },
  "type": "react-vite"
}
</file>

<file path="src/pages/css/Reservas.css">
/* src/pages/css/Reservas.css */
/* Estilos actualizados para la página de reservas */

.reservas-page {
  --background: url('/img/fondoLoginRegistro.jpg') no-repeat center center / cover;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.reserva-form-container {
  padding: 20px 0;
  max-width: 800px;
  margin: 0 auto;
}

.reserva-form {
  background-color: #111111;
  border-radius: 5px;
  overflow: hidden;
  padding: 0;
}

.form-group {
  padding: 15px;
  border-bottom: 1px solid #333;
}

.form-group:last-child {
  border-bottom: none;
}

.form-group label {
  display: block;
  color: white;
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 8px;
}

.reserva-select {
  width: 100%;
  background-color: #1c1c1c;
  color: white;
  border-radius: 4px;
  --placeholder-color: #999;
}

.fecha-selector {
  background-color: #1c1c1c;
  border-radius: 4px;
  padding: 12px 16px;
  display: flex;
  align-items: center;
  cursor: pointer;
}

.fecha-placeholder, .fecha-seleccionada {
  display: flex;
  align-items: center;
  gap: 10px;
  color: white;
}

.fecha-placeholder span {
  color: #999;
}

.fecha-selector ion-icon {
  color: #0066cc;
  font-size: 20px;
}

.horarios-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
  margin-bottom: 15px;
}

.horario-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  background-color: #1c1c1c;
  color: white;
  border-radius: 20px;
  padding: 8px 12px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.horario-chip.selected {
  background-color: #0066cc;
}

.horario-chip ion-icon {
  color: #0066cc;
  font-size: 16px;
}

.horario-chip.selected ion-icon {
  color: white;
}

/* Estilos para el resumen de reserva */
.resumen-card {
  margin: 15px;
  border-radius: 8px;
  background-color: #1c1c1c;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.resumen-card ion-card-header {
  background-color: #0066cc;
}

.resumen-card ion-card-title {
  color: white;
  font-size: 18px;
  font-weight: 600;
}

.resumen-card ion-card-content {
  color: white;
  padding: 15px;
}

.resumen-card ion-row {
  margin-bottom: 8px;
}

.resumen-card ion-icon {
  font-size: 20px;
  margin-top: 2px;
}

/* Estilos para el precio total */
.precio-total-container {
  padding: 15px;
  margin: 0 15px 15px;
  background-color: rgba(0, 102, 204, 0.1);
  border-radius: 8px;
}

.precio-total {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.precio-total label {
  font-size: 18px;
  font-weight: 600;
  color: white;
  margin: 0;
}

.precio-valor {
  font-size: 24px;
  font-weight: 700;
  color: #0066cc;
}

.notas-textarea {
  width: 100%;
  background-color: #1c1c1c;
  border-radius: 4px;
  --placeholder-color: #999;
  --color: white;
}

.reservar-button {
  margin: 20px 15px;
  --background: #0066cc;
  --background-activated: #0055aa;
  --border-radius: 4px;
  --box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
  height: 50px;
  font-size: 16px;
  font-weight: 600;
}

/* Ajustes para el datetime popover */
.date-popover {
  --width: 300px;
  --offset-y: 0px !important;
}

ion-popover.date-popover {
  --box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

ion-datetime {
  --background: #1c1c1c;
  --color: white;
  --background-rgb: 28, 28, 28;
}

/* Media queries para responsividad */
@media (max-width: 576px) {
  .form-group {
    padding: 12px;
  }
  
  .horario-chip {
    font-size: 12px;
    padding: 6px 10px;
  }
  
  .precio-valor {
    font-size: 22px;
  }
  
  .reservar-button {
    height: 46px;
    font-size: 14px;
  }
  
  .resumen-card ion-card-title {
    font-size: 16px;
  }
}
</file>

<file path="package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test.e2e": "cypress run",
    "test.unit": "vitest",
    "lint": "eslint",
    "ionic:build": "npm run build",
    "ionic:serve": "npm run dev -- --open"
  },
  "dependencies": {
    "@capacitor/android": "7.0.1",
    "@capacitor/app": "7.0.0",
    "@capacitor/core": "7.0.1",
    "@capacitor/haptics": "7.0.0",
    "@capacitor/ios": "7.0.1",
    "@capacitor/keyboard": "7.0.0",
    "@capacitor/status-bar": "7.0.0",
    "@ionic/react": "^8.4.3",
    "@ionic/react-router": "^8.4.3",
    "@types/react-router": "^5.1.20",
    "@types/react-router-dom": "^5.3.3",
    "axios": "^1.8.4",
    "ionicons": "^7.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router": "^5.3.4",
    "react-router-dom": "^5.3.4"
  },
  "devDependencies": {
    "@capacitor/cli": "7.0.1",
    "@testing-library/dom": ">=7.21.4",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/react": "^18.0.27",
    "@types/react-dom": "^18.0.10",
    "@vitejs/plugin-legacy": "^6.0.2",
    "@vitejs/plugin-react": "^4.0.1",
    "cypress": "^13.5.0",
    "eslint": "^9.20.1",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "jsdom": "^22.1.0",
    "terser": "^5.4.0",
    "typescript": "^5.1.6",
    "typescript-eslint": "^8.24.0",
    "vite": "^6.2.2",
    "vitest": "^3.0.8"
  }
}
</file>

<file path="src/pages/css/Login.css">
/* src/pages/css/Login.css */

.login-container {
  --background: url('/img/fondoLoginRegistro.jpg') no-repeat center center / cover;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.login-card {
  margin: 0 auto;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  overflow: hidden;
  margin-top: 20px;
}

.login-card-header {
  background-color: #0066cc;
  color: white;
  padding: 20px;
}

.login-card-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.login-card-content {
  padding: 20px;
  background-color: #1c1c1c;
}

.login-form {
  margin-bottom: 20px;
}

.login-form ion-item {
  --border-radius: 8px;
  --background: #1c1c1c;
  --padding-start: 12px;
  margin-bottom: 16px;
  --border-color: rgba(255, 255, 255, 0.1);
  --highlight-color-focused: #0066cc;
  --min-height: 65px;
}

.login-form ion-input {
  --padding-start: 8px;
  --placeholder-color: #999;
  --padding-top: 24px;
  --padding-bottom: 8px;
  font-size: 16px;
  --color: white;
}

.login-form ion-label {
  font-weight: 500;
  font-size: 16px;
  margin-bottom: 16px;
  --color: #dddddd;
}

.login-button {
  margin-top: 20px;
  --border-radius: 8px;
  --background: #0066cc;
  --background-hover: #0066cc;
  font-weight: 600;
  height: 48px;
  text-transform: none;
  font-size: 16px;
}

.login-footer {
  text-align: center;
  margin-top: 30px;
}

.login-footer p {
  color: #dddddd;
  font-size: 15px;
}

.login-footer ion-router-link {
  color: #0066cc;
  font-weight: 500;
  text-decoration: none;
}

.error-message {
  color: #eb445a;
  font-size: 14px;
  margin-bottom: 15px;
  padding: 0 12px;
}

.login-card {
  margin: 0 auto;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  overflow: hidden;
  margin-top: 20px;
  max-width: 650px;
  width: 90%; 
}

/* Responsive adjustments */
@media (max-width: 576px) {
  .login-card {
    margin-top: 10px;
  }
  
  .login-card-header h2 {
    font-size: 20px;
  }
}

@media (min-width: 768px) {
  .login-container {
    padding: 30px;
  }
}
</file>

<file path="src/pages/css/ManageCourts.css">
/* src/pages/css/ManageCourts.css */

.manage-courts-container {
  --background: url('/img/fondoLoginRegistro.jpg') no-repeat center center / cover;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.info-card,
.courts-card {
  margin-bottom: 16px;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  background-color: #1c1c1c;
  color: white;
  padding: 16px;
}

.no-courts {
  text-align: center;
  padding: 30px 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.no-courts ion-icon {
  font-size: 48px;
  color: #0066cc;
  margin-bottom: 16px;
}

.no-courts p {
  font-size: 18px;
  color: #dddddd;
  margin-bottom: 20px;
}

ion-item-sliding {
  margin-bottom: 8px;
}

ion-item {
  --background: #1c1c1c;
  --color: white;
  --border-color: rgba(255, 255, 255, 0.1);
  --padding-start: 16px;
  margin-bottom: 16px;
}

ion-item-options {
  height: auto;
}

ion-item-option {
  min-height: 80px;
  display: flex;
  align-items: center;
  padding: 10px;
}

ion-item h2 {
  font-weight: 600;
  font-size: 18px;
  margin-bottom: 4px;
  color: white;
}

ion-item p {
  color: #dddddd;
  font-size: 14px;
  margin: 4px 0;
}

ion-chip [color="success"]{
  --background: rgba(255, 165, 0, 0.1);
  --color: rgb(15, 211, 81);
  border: 1px solid green;
}

ion-chip[color="warning"] {
  --background: rgba(255, 165, 0, 0.1);
  --color: orange;
  border: 1px solid orange;
}


ion-modal {
  --border-radius: 20px;
  --box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

ion-modal ion-content {
  --padding-top: 16px;
  --padding-bottom: 16px;
  --background: #111111;
}

ion-modal ion-toolbar {
  --background: #0066cc;
  --color: white;
  border-top-left-radius: 16px; /* Bordes redondeados en la parte superior del toolbar */
  border-top-right-radius: 16px;
}

ion-modal ion-title {
  font-size: 20px;
  font-weight: 600;
}

ion-modal ion-item {
  --background: #1c1c1c;
  --color: white;
  --border-color: rgba(255, 255, 255, 0.1);
  --padding-start: 16px; /* Margen a la izquierda */
  margin-bottom: 16px;
}

ion-modal ion-label {
  font-weight: 500;
  color: #dddddd;
  font-size: 16px;
}

ion-modal ion-input,
ion-modal ion-select,
ion-modal ion-textarea {
  --color: white;
  --placeholder-color: #999;
  --background: #1c1c1c;
  border-radius: 8px;
  padding: 12px;
  margin-top: 8px;
}

ion-select{
  margin-bottom: 18px;
}

ion-toggle {
  position: absolute;
  right: 16px;
  transform: translateX(0);
  width: auto;
}

ion-modal ion-textarea {
  min-height: 100px;
}

/* Botón de guardar en el modal */
.save-button {
  background-color: #0066cc;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
  font-weight: 600;
  height: 50px;
  font-size: 16px;
  margin: 20px 16px;
}

/* Estilos para los horarios disponibles */
.available-times {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}

.time-chip {
  background-color: #2c2c2c;
  color: white;
  border-radius: 20px;
  padding: 8px 12px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.time-chip.selected {
  background-color: #0066cc;
  color: white;
}

/* Responsive */
@media (max-width: 576px) {
  .info-card,
  .courts-card {
    padding: 12px;
  }

  .no-courts p {
    font-size: 16px;
  }

  ion-item h2 {
    font-size: 16px;
  }

  ion-item p {
    font-size: 12px;
  }

  .save-button {
    height: 46px;
    font-size: 14px;
  }
}
</file>

<file path="src/pages/css/Profile.css">
.profile-container {
  --background: #111111;
  color: white;
}

/* Para asegurar que los títulos de secciones sean blancos */
.profile-container h2, 
.profile-container h3, 
.profile-container h4,
.profile-container ion-card-title,
.profile-container ion-title {
  color: white !important;
}

/* Para el contenedor principal de información */
ion-card, 
.profile-card {
  background-color: #1c1c1c;
  color: white;
}

/* Para títulos de cards */
ion-card-header {
  color: white;
}

ion-card-title {
  color: white !important;
}

.profile-header {
  padding: 20px;
  background-color: #3880ff;
  color: white;
  text-align: center;
}

.profile-avatar {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  margin: 0 auto;
  border: 3px solid white;
  overflow: hidden;
  margin-bottom: 10px;
  position: relative;
}

/* Nuevo estilo para hacer el avatar clickable */
.profile-avatar:hover {
  cursor: pointer;
  opacity: 0.9;
}

/* Texto para editar avatar */
.edit-avatar-text {
  margin-top: -5px;
  margin-bottom: 10px;
}

.profile-name {
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 5px;
}

.profile-card {
  margin: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.profile-form ion-item {
  --padding-start: 0;
  --min-height: 50px;
}

.profile-form ion-label {
  font-weight: 500;
  color: #555;
  margin-bottom: 5px;
}

.profile-form ion-input, 
.profile-form ion-textarea {
  --padding-top: 25px;
  --padding-bottom: 8px;
}

/* Añadido para dar más espacio entre título y valor */
.profile-form ion-item ion-label + ion-input {
  margin-top: 5px;
}

.profile-form ion-select {
  margin-top: 20px;
}

.form-buttons {
  display: flex;
  justify-content: space-between;
  margin-top: 15px;
}

.avatar-upload {
  text-align: center;
  margin: 20px 0;
}

.avatar-preview {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  object-fit: cover;
  margin: 0 auto;
  display: block;
  border: 2px solid #ddd;
}

.success-message {
  color: #2dd36f;
  margin: 10px 0;
  text-align: center;
}

.error-message {
  color: #eb445a;
  margin: 10px 0;
  text-align: center;
}
</file>

<file path="src/pages/Login.tsx">
// src/pages/Login.tsx
import React, { useState, useRef, useEffect } from 'react';
import { 
  IonContent, 
  IonHeader, 
  IonPage, 
  IonTitle, 
  IonToolbar,
  IonInput,
  IonItem,
  IonLabel,
  IonButton,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardTitle,
  IonText,
  IonLoading,
  IonRouterLink,
  IonGrid,
  IonRow,
  IonCol,
  IonIcon,
  useIonViewWillLeave
} from '@ionic/react';
import { mailOutline, lockClosedOutline } from 'ionicons/icons';
import { useHistory } from 'react-router';
import { useAuth } from '../context/AuthContext';
import './css/Login.css';

const Login: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [formError, setFormError] = useState('');
  const [showLoading, setShowLoading] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const formRef = useRef<HTMLFormElement>(null);
  const emailInputRef = useRef<HTMLIonInputElement>(null);
  const passwordInputRef = useRef<HTMLIonInputElement>(null);
  
  const { login } = useAuth();
  const history = useHistory();
  
  // Limpiar el foco antes de abandonar la vista
  useIonViewWillLeave(() => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  });

  // Efecto para manejar el envío del formulario después de que los estados se actualicen
  useEffect(() => {
    const performLogin = async () => {
      if (!isSubmitting) return;
      
      try {
        // Los estados de email y password ya deberían estar actualizados
        // Validación básica
        if (!email || !password) {
          setFormError('Por favor, completa todos los campos');
          setIsSubmitting(false);
          return;
        }
        
        setShowLoading(true);
        setFormError('');
        
        // Llamar a la función login del contexto
        await login({ email, password });
        
        // Redirigir al home - usar replace en lugar de push para evitar la duplicación
        history.replace('/home');
      } catch (error: any) {
        console.error('Error en login:', error);
        setFormError(error.message || 'Error al iniciar sesión. Verifica tus credenciales.');
      } finally {
        setShowLoading(false);
        setIsSubmitting(false);
      }
    };
    
    performLogin();
  }, [isSubmitting, email, password, login, history]);

  const handleLogin = (e: React.FormEvent) => {
    e.preventDefault();
    
    // En lugar de ejecutar la lógica aquí, sólo marcamos que estamos enviando
    // y dejamos que el useEffect se encargue de la lógica
    setIsSubmitting(true);
    
    // Eliminar el foco de cualquier elemento activo
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  };
  
  // Manejador para teclas especiales
  const handleKeyDown = (e: React.KeyboardEvent<HTMLIonInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      
      // Forzar la actualización del estado antes de enviar el formulario
      const target = e.currentTarget;
      if (target.name === 'email') {
        setEmail(target.value?.toString() || '');
      } else if (target.name === 'password') {
        setPassword(target.value?.toString() || '');
      }
      
      // Usar setTimeout para asegurar que los estados se actualizan antes de enviar
      setTimeout(() => {
        if (formRef.current) {
          formRef.current.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
        }
      }, 0);
    }
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonTitle>Play4Padel - Iniciar Sesión</IonTitle>
        </IonToolbar>
      </IonHeader>
      <IonContent className="login-container">
        <IonGrid>
          <IonRow className="ion-justify-content-center">
            <IonCol size="12" sizeMd="8" sizeLg="6">
              <IonCard className="login-card">
                <IonCardHeader className="login-card-header">
                  <IonCardTitle className="ion-text-center">
                    <h2>Bienvenido a Play4Padel</h2>
                  </IonCardTitle>
                </IonCardHeader>
                <IonCardContent className="login-card-content">
                  <form ref={formRef} className="login-form" onSubmit={handleLogin}>
                    <IonItem lines="full">
                      <IonIcon icon={mailOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">Email</IonLabel>
                      <IonInput 
                        ref={emailInputRef}
                        name="email"
                        type="email" 
                        value={email} 
                        onIonChange={e => setEmail(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                        required
                      />
                    </IonItem>
                    <IonItem lines="full">
                      <IonIcon icon={lockClosedOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">Contraseña</IonLabel>
                      <IonInput 
                        ref={passwordInputRef}
                        name="password"
                        type="password" 
                        value={password} 
                        onIonChange={e => setPassword(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                        required
                      />
                    </IonItem>
                    
                    {formError && (
                      <div className="error-message">
                        <IonText color="danger">
                          <p>{formError}</p>
                        </IonText>
                      </div>
                    )}
                    
                    <IonButton 
                      expand="block" 
                      type="submit" 
                      className="login-button"
                      disabled={isSubmitting}
                    >
                      Iniciar Sesión
                    </IonButton>
                  </form>
                  
                  <div className="login-footer">
                    <p>
                      ¿No tienes cuenta? 
                      <IonRouterLink href="/register" className="ion-padding-start">
                        Regístrate
                      </IonRouterLink>
                    </p>
                  </div>
                </IonCardContent>
              </IonCard>
            </IonCol>
          </IonRow>
        </IonGrid>
        
        <IonLoading
          isOpen={showLoading}
          message={'Iniciando sesión...'}
          spinner="circles"
        />
      </IonContent>
    </IonPage>
  );
};

export default Login;
</file>

<file path="src/pages/ManageCourts.tsx">
// src/pages/ManageCourts.tsx
import React, { useState, useEffect } from 'react';
import {
  IonContent,
  IonHeader,
  IonPage,
  IonTitle,
  IonToolbar,
  IonButtons,
  IonBackButton,
  IonGrid,
  IonRow,
  IonCol,
  IonCard,
  IonCardHeader,
  IonCardTitle,
  IonCardContent,
  IonItem,
  IonLabel,
  IonInput,
  IonSelect,
  IonSelectOption,
  IonToggle,
  IonButton,
  IonIcon,
  IonList,
  IonItemSliding,
  IonItemOptions,
  IonItemOption,
  IonLoading,
  IonToast,
  IonText,
  IonModal,
  IonChip,
  IonFab,
  IonFabButton,
  IonAlert
} from '@ionic/react';
import {
  addCircleOutline,
  createOutline,
  buildOutline,
  trashOutline,
  closeCircleOutline,
  checkmarkCircleOutline,
  tennisballOutline
} from 'ionicons/icons';
import { useAuth } from '../context/AuthContext';
import { useHistory } from 'react-router-dom';
import apiService from '../services/api.service';
import { API_ENDPOINTS } from '../utils/constants';
import './css/ManageCourts.css';

// Interfaz para los datos de la pista
interface Pista {
  id: number;
  numero: number;
  id_club: number;
  tipo: string;
  estado: string;
  precio_hora: number;
  iluminacion: boolean;
  techada: boolean;
  imagen_url?: string;
}

const ManageCourts: React.FC = () => {
  const { user } = useAuth();
  const history = useHistory();
  
  // Estados
  const [clubId, setClubId] = useState<number | null>(null);
  const [clubData, setClubData] = useState<any>(null);
  const [pistas, setPistas] = useState<Pista[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [showToast, setShowToast] = useState<boolean>(false);
  const [toastMessage, setToastMessage] = useState<string>('');
  const [toastColor, setToastColor] = useState<string>('success');
  const [showModal, setShowModal] = useState<boolean>(false);
  const [editingPista, setEditingPista] = useState<Pista | null>(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState<boolean>(false);
  const [courtToDelete, setCourtToDelete] = useState<number | null>(null);
  
  // Form state
  const [formData, setFormData] = useState({
    numero: '',
    tipo: 'standard',
    precio_hora: '',
    iluminacion: true,
    techada: false,
    imagen_url: ''
  });
  
  // Cargar datos del club y pistas cuando se monta el componente
  useEffect(() => {
    const loadClubData = async () => {
      if (!user || user.id_rol !== 1) {
        // Redirigir si no es administrador
        history.replace('/home');
        return;
      }
      
      try {
        setLoading(true);
        // Buscar club por id_administrador
        const clubsResponse = await apiService.get(`/clubs?id_administrador=${user.id}`);
        
        if (clubsResponse && clubsResponse.length > 0) {
          const club = clubsResponse[0];
          setClubId(club.id);
          setClubData(club);
          
          // Cargar pistas del club
          const pistasResponse = await apiService.get(`/clubs/${club.id}/pistas`);
          if (Array.isArray(pistasResponse)) {
            setPistas(pistasResponse);
          } else {
            // Si no hay pistas o el endpoint devuelve un formato diferente
            setPistas([]);
          }
        } else {
          showToastMessage('No se encontró información del club', 'warning');
        }
      } catch (error) {
        console.error('Error al cargar datos:', error);
        showToastMessage('Error al cargar datos del club', 'danger');
      } finally {
        setLoading(false);
      }
    };
    
    loadClubData();
  }, [user, history]);
  
  // Mostrar mensaje de toast
  const showToastMessage = (message: string, color: string = 'success') => {
    setToastMessage(message);
    setToastColor(color);
    setShowToast(true);
  };
  
  // Manejar cambios en el formulario
  const handleInputChange = (e: CustomEvent, field: string) => {
    const value = e.detail.value;
    setFormData({
      ...formData,
      [field]: value
    });
  };
  
  // Manejar cambios en toggles
  const handleToggleChange = (e: CustomEvent, field: string) => {
    const checked = e.detail.checked;
    setFormData({
      ...formData,
      [field]: checked
    });
  };
  
  // Abrir modal para crear nueva pista
  const openCreateModal = () => {
    setEditingPista(null);
    setFormData({
      numero: '',
      tipo: 'standard',
      precio_hora: '',
      iluminacion: true,
      techada: false,
      imagen_url: ''
    });
    setShowModal(true);
  };
  
  // Abrir modal para editar pista
  const openEditModal = (pista: Pista) => {
    setEditingPista(pista);
    setFormData({
      numero: pista.numero.toString(),
      tipo: pista.tipo,
      precio_hora: pista.precio_hora.toString(),
      iluminacion: pista.iluminacion,
      techada: pista.techada,
      imagen_url: pista.imagen_url || ''
    });
    setShowModal(true);
  };
  
  // Guardar pista (crear o actualizar)
  const saveCourt = async () => {
    if (!clubId) {
      showToastMessage('No se ha seleccionado un club', 'danger');
      return;
    }
    
    try {
      setLoading(true);
      
      // Validar datos
      if (!formData.numero || !formData.precio_hora) {
        showToastMessage('Por favor, complete los campos requeridos', 'warning');
        setLoading(false);
        return;
      }
      
      // Preparar datos para enviar
      const pistaData = {
        numero: parseInt(formData.numero, 10),
        id_club: clubId,
        tipo: formData.tipo,
        estado: 'disponible',
        precio_hora: parseFloat(formData.precio_hora),
        iluminacion: formData.iluminacion,
        techada: formData.techada,
        imagen_url: formData.imagen_url
      };
      
      let response;
      
      if (editingPista) {
        // Actualizar pista existente
        response = await apiService.put(`/pistas/${editingPista.id}`, pistaData);
        showToastMessage('Pista actualizada correctamente');
      } else {
        // Crear nueva pista
        response = await apiService.post(`/clubs/${clubId}/pistas`, pistaData);
        showToastMessage('Pista creada correctamente');
      }
      
      // Actualizar lista de pistas
      const pistasResponse = await apiService.get(`/clubs/${clubId}/pistas`);
      if (Array.isArray(pistasResponse)) {
        setPistas(pistasResponse);
      }
      
      // Cerrar modal
      setShowModal(false);
      
    } catch (error) {
      console.error('Error al guardar pista:', error);
      showToastMessage('Error al guardar la pista', 'danger');
    } finally {
      setLoading(false);
    }
  };
  
  // Cambiar estado de la pista
  const changeCourtStatus = async (pistaId: number, newStatus: string) => {
    try {
      setLoading(true);
      
      await apiService.put(`/pistas/${pistaId}`, { estado: newStatus });
      
      showToastMessage(`Estado de la pista actualizado a ${newStatus}`);
      
      // Actualizar lista de pistas
      const pistasResponse = await apiService.get(`/clubs/${clubId}/pistas`);
      if (Array.isArray(pistasResponse)) {
        setPistas(pistasResponse);
      }
    } catch (error) {
      console.error('Error al cambiar estado de la pista:', error);
      showToastMessage('Error al cambiar el estado de la pista', 'danger');
    } finally {
      setLoading(false);
    }
  };
  
  // Eliminar pista
  const prepareDeleteCourt = (pistaId: number) => {
    setCourtToDelete(pistaId);
    setShowDeleteConfirm(true);
  };
  

  const confirmDeleteCourt = async () => {
    if (!courtToDelete) return;
    
    try {
      setLoading(true);
      
      await apiService.delete(`/pistas/${courtToDelete}`);
      
      showToastMessage('Pista eliminada correctamente');
      
      // Actualizar lista de pistas
      setPistas(pistas.filter(pista => pista.id !== courtToDelete));
    } catch (error) {
      console.error('Error al eliminar pista:', error);
      showToastMessage('Error al eliminar la pista', 'danger');
    } finally {
      setLoading(false);
      setShowDeleteConfirm(false);
      setCourtToDelete(null);
    }
  };
  
  // Obtener color según estado
  const getStatusColor = (estado: string): string => {
    switch (estado) {
      case 'disponible':
        return 'success';
      case 'mantenimiento':
        return 'warning';
      case 'cerrada':
        return 'danger';
      default:
        return 'medium';
    }
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/home" />
          </IonButtons>
          <IonTitle>Gestión de Pistas</IonTitle>
        </IonToolbar>
      </IonHeader>
      
      <IonContent className="manage-courts-container">
        <IonGrid>
          <IonRow>
            <IonCol size="12" sizeMd="8" offsetMd="2">
              <IonCard className="info-card">
                <IonCardHeader>
                  <IonCardTitle>
                    {clubData ? clubData.nombre : 'Club'}
                  </IonCardTitle>
                </IonCardHeader>
                <IonCardContent>
                  <p>
                    Gestione las pistas de su club. Puede crear, editar y cambiar el estado de las pistas.
                  </p>
                </IonCardContent>
              </IonCard>
              
              <IonCard className="courts-card">
                <IonCardHeader>
                  <IonCardTitle>Pistas</IonCardTitle>
                </IonCardHeader>
                <IonCardContent>
                  {pistas.length === 0 ? (
                    <div className="no-courts">
                      <IonIcon icon={tennisballOutline} size="large" />
                      <IonText color="medium">
                        <p>No hay pistas creadas</p>
                      </IonText>
                      <IonButton 
                        expand="block" 
                        onClick={openCreateModal}
                      >
                        <IonIcon slot="start" icon={addCircleOutline} />
                        Crear Nueva Pista
                      </IonButton>
                    </div>
                  ) : (
                    <IonList>
                      {pistas.map((pista) => (
                        <IonItemSliding key={pista.id}>
                          <IonItem>
                            <IonLabel>
                              <h2>Pista {pista.numero}</h2>
                              <p>
                                {pista.tipo} - {pista.precio_hora}€/hora
                              </p>
                              <p>
                                {pista.iluminacion ? 'Con iluminación' : 'Sin iluminación'} - 
                                {pista.techada ? ' Cubierta' : ' Descubierta'}
                              </p>
                            </IonLabel>
                            <IonChip 
                              color={getStatusColor(pista.estado)} 
                              slot="end"
                            >
                              {pista.estado}
                            </IonChip>
                          </IonItem>
                          
                          <IonItemOptions side="end">
                            <IonItemOption 
                              color="primary" 
                              onClick={() => openEditModal(pista)}
                            >
                              <IonIcon slot="icon-only" icon={createOutline} />
                            </IonItemOption>
                            <IonItemOption 
                              color="danger" 
                              onClick={() => prepareDeleteCourt(pista.id)}
                            >
                              <IonIcon slot="icon-only" icon={trashOutline} />
                            </IonItemOption>
                          </IonItemOptions>
                          
                          <IonItemOptions side="start">
                            {pista.estado !== 'disponible' && (
                              <IonItemOption 
                                color="success" 
                                onClick={() => changeCourtStatus(pista.id, 'disponible')}
                              >
                                <IonIcon slot="icon-only" icon={checkmarkCircleOutline} />
                              </IonItemOption>
                            )}
                            {pista.estado !== 'mantenimiento' && (
                              <IonItemOption 
                                color="warning" 
                                onClick={() => changeCourtStatus(pista.id, 'mantenimiento')}
                              >
                                <IonIcon slot="icon-only" icon={buildOutline} />
                              </IonItemOption>
                            )}
                            {pista.estado !== 'cerrada' && (
                              <IonItemOption 
                                color="danger" 
                                onClick={() => changeCourtStatus(pista.id, 'cerrada')}
                              >
                                <IonIcon slot="icon-only" icon={closeCircleOutline} />
                              </IonItemOption>
                            )}
                          </IonItemOptions>
                        </IonItemSliding>
                      ))}
                    </IonList>
                  )}
                </IonCardContent>
              </IonCard>
            </IonCol>
          </IonRow>
        </IonGrid>
        
        <IonFab vertical="bottom" horizontal="end" slot="fixed">
          <IonFabButton onClick={openCreateModal}>
            <IonIcon icon={addCircleOutline} />
          </IonFabButton>
        </IonFab>
        
        {/* Modal para añadir o editar pista */}
        <IonModal isOpen={showModal} onDidDismiss={() => setShowModal(false)}>
          <IonHeader>
            <IonToolbar>
              <IonTitle>
                {editingPista ? 'Editar Pista' : 'Nueva Pista'}
              </IonTitle>
              <IonButtons slot="end">
                <IonButton onClick={() => setShowModal(false)}>
                  Cancelar
                </IonButton>
              </IonButtons>
            </IonToolbar>
          </IonHeader>
          <IonContent>
            <IonGrid>
              <IonRow>
                <IonCol size="12">
                  <IonItem>
                    <IonLabel position="floating">Número de Pista *</IonLabel>
                    <IonInput
                      type="number"
                      value={formData.numero}
                      onIonChange={(e) => handleInputChange(e, 'numero')}
                      required
                    />
                  </IonItem>
                  
                  <IonItem>
                    <IonLabel position="floating">Tipo de Pista *</IonLabel>
                    <IonSelect value={formData.tipo} onIonChange={(e) => handleInputChange(e, 'tipo')} placeholder="Elegir">
                      <IonSelectOption value="Indoor">Indoor</IonSelectOption>
                      <IonSelectOption value="Outdoor">Outdoor</IonSelectOption>
                    </IonSelect>
                  </IonItem>
                  
                  <IonItem>
                    <IonLabel position="floating">Precio por Hora (€) *</IonLabel>
                    <IonInput
                      type="number"
                      value={formData.precio_hora}
                      onIonChange={(e) => handleInputChange(e, 'precio_hora')}
                      required
                    />
                  </IonItem>
                  
                  <IonItem>
                    <IonLabel>Con Iluminación</IonLabel>
                    <IonToggle
                      checked={formData.iluminacion}
                      onIonChange={(e) => handleToggleChange(e, 'iluminacion')}
                    />
                  </IonItem>
                  
                  <IonItem>
                    <IonLabel>Pista Cubierta</IonLabel>
                    <IonToggle
                      checked={formData.techada}
                      onIonChange={(e) => handleToggleChange(e, 'techada')}
                    />
                  </IonItem>
                  
                  <IonItem>
                    <IonLabel position="floating">URL de Imagen</IonLabel>
                    <IonInput
                      type="text"
                      value={formData.imagen_url}
                      onIonChange={(e) => handleInputChange(e, 'imagen_url')}
                    />
                  </IonItem>
                  
                  <div className="ion-padding">
                    <IonButton
                      expand="block"
                      onClick={saveCourt}
                    >
                      {editingPista ? 'Actualizar Pista' : 'Crear Pista'}
                    </IonButton>
                  </div>
                </IonCol>
              </IonRow>
            </IonGrid>
          </IonContent>
        </IonModal>

        <IonAlert
          isOpen={showDeleteConfirm}
          onDidDismiss={() => setShowDeleteConfirm(false)}
          header="¿Eliminar pista?"
          message=" Esta acción no se puede deshacer"
          buttons={[
            {
              text: 'Cancelar',
              role: 'cancel',
              cssClass: 'secondary',
              handler: () => {
                setShowDeleteConfirm(false);
                setCourtToDelete(null);
              }
            },
            {
              text: 'Eliminar',
              cssClass: 'danger',
              handler: confirmDeleteCourt
            }
          ]}
        />
        
        <IonLoading isOpen={loading} message="Procesando..." />
        
        <IonToast
          isOpen={showToast}
          onDidDismiss={() => setShowToast(false)}
          message={toastMessage}
          duration={2000}
          position="bottom"
          color={toastColor}
        />
      </IonContent>
    </IonPage>
  );
};

export default ManageCourts;
</file>

<file path="src/utils/constants.ts">
// src/utils/constants.ts
export const API_URL = 'http://localhost:5000';

export const API_ENDPOINTS = {
  LOGIN: '/login',
  REGISTER: '/create-user',
  LOGOUT: '/logout',
  USER: '/user',
  UPDATE_PASSWORD: '/update-password',
  CLUBS: '/clubs',
  RESERVAS: '/reservas',
  CREAR_RESERVA: '/crear-reserva',
  DISPONIBILIDAD_PISTA: '/pistas'
};

export const STORAGE_KEYS = {
  AUTH_TOKEN: 'auth_token',
  USER_ID: 'user_id',
  USER_ROLE: 'user_role',
};

export const ROLES = {
  ADMIN: 'ADMIN',
  PROFESOR: 'PROFESOR',
  EMPLEADO: 'EMPLEADO',
  USUARIO: 'USUARIO',
  SOCIO: 'SOCIO',
};

export const ESTADOS_RESERVA = {
  PENDIENTE: 'pendiente',
  CONFIRMADA: 'confirmada', 
  CANCELADA: 'cancelada',
  COMPLETADA: 'completada'
};

export const TIPOS_CUENTA = {
  USUARIO: 'usuario',
  CLUB: 'club'
};
</file>

<file path="src/interfaces/index.ts">
// src/interfaces/index.ts
export interface User {
  id: number;
  nombre: string;
  apellidos: string;
  email: string;
  telefono?: string;
  id_rol: number;
  id_club?: number;
  avatar_url?: string;
  bio?: string;
  activo: boolean;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  message: string;
  user_id: number;
  role: string;
}

export interface RegisterRequest {
  nombre: string;
  apellidos: string;
  email: string;
  password: string;
  id_rol: number;
  telefono?: string;
  avatar_url?: string;
  bio?: string;
  tipo_cuenta?: string;
  // Campos específicos para club
  club_data?: {
    nombre: string;
    direccion: string;
    horario_apertura: string;
    horario_cierre: string;
    descripcion?: string;
    telefono?: string;
    email?: string;
  };
}

export interface RegisterResponse {
  message: string;
  user_id?: number;
}

export interface UpdatePasswordRequest {
  user_id: number;
  current_password: string;
  new_password: string;
}

export interface UpdateProfileRequest {
  nombre?: string;
  apellidos?: string;
  email?: string;
  telefono?: string;
  avatar_url?: string;
  bio?: string;
}

export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  login: (data: LoginRequest) => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
}

export interface ClubData {
  id: number;
  nombre: string;
  descripcion: string;
  direccion: string;
  telefono: string;
  email: string;
  horario_apertura: string;
  horario_cierre: string;
  id_administrador: number;
  fecha_registro: string;
  activo: boolean;
  imagen_url?: string;
  sitio_web?: string;
  redes_sociales?: any;
}
</file>

<file path="src/pages/css/CalendarView.css">
.calendar-view {
  --background: #111111;
  color: white;
}

/* Vista segmentada */
ion-segment {
  margin: 10px;
  --background: #1c1c1c;
}

ion-segment-button {
  --indicator-color: #3880ff;
  --color-checked: white;
  --color: #999;
}

/* Navegación del calendario */
.navegacion-calendario {
  display: flex;
  justify-content: space-between; /* Distribuir los elementos correctamente */
  align-items: center;
  width: 100%;
  max-width: 600px;
  margin: 0 auto 15px auto;
  padding: 0 15px; /* Espacio a los lados */
  position: relative;
}

.titulo-mes {
  color: white;
  text-transform: capitalize;
  font-size: 1.3rem;
  font-weight: 600;
  text-align: center;
  flex-grow: 1; /* Para ocupar el espacio disponible */
  text-align: center;
}

/* Botones de navegación (flechas) */
.navegacion-calendario ion-button {
  flex-shrink: 0;
  min-width: 40px; /* Asegurar un tamaño mínimo */
}

/* Flecha izquierda */
.navegacion-calendario ion-button:first-child {
  left: 10px;
  margin-right: 0;
}

/* Flecha derecha */
.navegacion-calendario ion-button:nth-child(2) {
  right: 10px;
  margin-left: 0;
}

.boton-hoy {
  margin-left: auto; /* Empuja el botón a la derecha */
}

/* Grid del calendario */
.grid-calendario {
  padding: 0;
  margin-bottom: 20px;
  width: 95%;
  margin-left: auto;
  margin-right: auto;
}

ion-grid.grid-calendario {
  width: 90% !important;
  max-width: 1200px !important;
}

/* Asegurar que cada celda de día tenga espacio suficiente */
.dia {
  width: calc(100% / 7); /* Cada día ocupa 1/7 del ancho total */
  min-width: 40px; /* Asegurar un ancho mínimo para los días */
}

.dias-semana {
  background-color: #1c1c1c;
  color: white;
  text-align: center;
  font-weight: 600;
  padding: 10px 0;
  border-bottom: 1px solid #333;
  border-top: 1px solid #333;
}

.semana {
  border-bottom: 1px solid #2c2c2c;
}

.dia {
  position: relative;
  height: 50px;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-right: 1px solid #2c2c2c;
  padding: 5px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.dia:last-child {
  border-right: none;
}

.dia.otro-mes {
  color: #666;
}

.dia.tiene-reservas {
  background-color: rgba(56, 128, 255, 0.2);
}

.dia.seleccionado {
  background-color: rgba(56, 128, 255, 0.5);
  font-weight: bold;
}

.numero-dia {
  font-size: 1rem;
  color: white;
}

.indicador-reservas {
  position: absolute;
  bottom: 2px;
  right: 5px;
  background-color: #3880ff;
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 0.7rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Panel de reservas */
.panel-reservas {
  background-color: #1c1c1c;
  border-radius: 10px 10px 0 0;
  padding: 15px 10px;
  margin-top: 10px;
  min-height: 300px;
}

.panel-reservas.pantalla-completa {
  border-radius: 0;
  padding-top: 0;
  margin-top: 0;
  min-height: 100%;
}

.fecha-seleccionada {
  text-align: center;
  margin-top: 5px;
  margin-bottom: 15px;
  font-size: 1.2rem;
  font-weight: 600;
  text-transform: capitalize;
}

.cabecera-lista {
  padding: 15px;
  background-color: #2c2c2c;
  margin-bottom: 10px;
}

.cabecera-lista h2 {
  margin: 0;
  font-size: 1.2rem;
  text-transform: capitalize;
}

/* Lista de reservas */
.lista-reservas {
  background-color: #1c1c1c;
}

.reserva-item {
  --background: #1c1c1c;
  --border-color: #333333;
}

.reserva-item.estado-cancelada {
  --opacity: 0.6;
}

/* Estilos para los divisores de fecha en la vista de lista */
ion-item-divider {
  --background: #2c2c2c;
  --color: white;
  font-weight: bold;
  text-transform: capitalize;
  margin-top: 10px;
}

.sin-dia-seleccionado,
.sin-reservas {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  text-align: center;
  padding: 20px;
}

/* Estilos para pantallas más grandes */
@media (min-width: 768px) {
  .dia {
    height: 80px;
  }
  
  .numero-dia {
    font-size: 1.2rem;
    margin-bottom: 10px;
  }
  
  .indicador-reservas {
    width: 22px;
    height: 22px;
    font-size: 0.8rem;
  }
  
  .panel-reservas {
    min-height: 400px;
  }
}

/* Para pantallas extra grandes */
@media (min-width: 1200px) {
  .grid-calendario {
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
  }
  
  .dia {
    height: 100px;
  }
}

/* Estilo para información de depuración */
pre.debug-info {
  text-align: left;
  font-size: 12px;
  background-color: #333;
  padding: 10px;
  border-radius: 5px;
  white-space: pre-wrap;
  margin-top: 15px;
  overflow: auto;
  max-height: 200px;
  border: 1px solid #555;
}

/* Estilo mejorado para cuando no hay reservas */
.sin-reservas {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 20px;
  text-align: center;
  min-height: 200px;
}

.sin-reservas p {
  margin-bottom: 15px;
  color: #999;
}

/* Estilo para resaltar el día actual */
.dia.hoy {
  background-color: rgba(56, 128, 255, 0.2);
  font-weight: bold;
}

/* Estilo para el botón de actualización */
ion-button.refresh-button {
  --padding-start: 12px;
  --padding-end: 12px;
}

@media (max-width: 480px) {
  .navegacion-calendario {
    padding: 0 10px;
  }
  
  .titulo-mes {
    font-size: 1rem;
    width: 60%;
  }
  
  .boton-hoy {
    font-size: 0.8rem;
    --padding-start: 8px;
    --padding-end: 8px;
    right: 50px;
  }
}

@media (max-width: 360px) {
  .navegacion-calendario {
    padding: 0 5px;
  }
  
  .titulo-mes {
    font-size: 0.9rem;
    width: 50%;
  }
  
  .boton-hoy {
    font-size: 0.7rem;
    --padding-start: 6px;
    --padding-end: 6px;
    right: 45px;
  }
}

.lista-reservas ion-item ion-icon[slot="start"],
.lista-reservas-mes ion-item ion-icon[slot="start"] {
  color: #28a745 !important;
}


.cargando-lista {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  color: white !important;
}
</file>

<file path="src/pages/css/Home.css">
/* src/pages/css/Home.css */

.home-container {
  --background: url('/img/fondoHome.jpg') no-repeat center center / cover;
  background-color: #121212;
}

.home-toolbar {
  --background: #3880ff;
  --color: white;
}

.welcome-card {
  margin: 0 auto;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  overflow: hidden;
  margin-top: 20px;
  background-color: #1c1c1c;
}

.welcome-card-header {
  background-color: #3880ff;
  color: white;
  padding: 20px;
}

.welcome-card-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.welcome-card-content {
  padding: 20px;
  background-color: #1c1c1c;
  color: white;
}


ion-list {
  background-color: #1c1c1c !important;
  --ion-item-background: #1c1c1c !important;
}

ion-item {
  --background: #1c1c1c !important;
  --color: white !important;
  --border-color: rgba(255, 255, 255, 0.1) !important;
}

ion-label {
  color: white !important;
}

.club-section ion-item,
.club-header ion-item,
.user-info ion-item {
  --background: #1c1c1c !important;
  --color: white !important;
}

.user-info ion-label h2 {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: white;
}

.user-info ion-text p {
  font-size: 14px;
  color: #cccccc;
}

.logout-button {
  --border-radius: 8px;
  --background: transparent;
  --color: #fff;
  font-weight: 600;
  text-transform: none;
  font-size: 14px;
}

.club-header {
  margin-bottom: 16px;
}

.club-header h2 {
  font-size: 24px;
  font-weight: 600;
  color: white;
}

.club-stats {
  margin: 20px 0;
}

.stat-card {
  text-align: center;
  padding: 16px;
  border-radius: 8px;
  background-color: #2c2c2c;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  color: white;
}

.stat-card ion-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.stat-card h3 {
  font-size: 24px;
  font-weight: 600;
  margin: 8px 0;
  color: white;
}

.stat-card p {
  color: #cccccc;
  margin: 0;
}

.section-title {
  margin: 24px 0 8px;
  font-size: 18px;
  font-weight: 600;
  color: white;
}

.club-action-button {
  margin-top: 24px;
}

.no-club-data {
  text-align: center;
  padding: 20px;
  color: #cccccc;
}

.no-club-data p {
  margin-bottom: 20px;
  color: #cccccc;
}

.membership-info {
  background-color: rgba(40, 167, 69, 0.1);
  border-radius: 8px;
  margin-top: 16px;
  margin-bottom: 16px;
  padding: 8px;
}

.membership-info ion-icon {
  color: #28a745 !important;
}

.membership-info h2 {
  color: #28a745;
  font-weight: 600;
  margin-bottom: 8px;
}

.membership-info p {
  margin: 4px 0;
  color: #e0e0e0;
}

.membership-info p strong {
  color: #fff;
}

@media (max-width: 576px) {
  .welcome-card {
    margin-top: 10px;
  }
  
  .welcome-card-header h2 {
    font-size: 20px;
  }
}

@media (min-width: 768px) {
  .home-container {
    padding: 30px;
  }
}
</file>

<file path="src/pages/css/ManageUsers.css">
.background-container {
  position: fixed;
  width: 100%;
  height: 100%;
  background: url('/img/fondoLoginRegistro.jpg') no-repeat center center / cover;
}

/* Fondo general del contenedor */
.manage-users-container {
  --background: url('/img/fondoLoginRegistro.jpg') no-repeat center center / cover !important;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* Destacar elemento de administrador */
.admin-item {
  --background: rgba(244, 67, 54, 0.2);
  border-left: 3px solid rgba(244, 67, 54, 0.2);;
}

/* Destacar elemento de socio */
.member-item {
  --background: rgba(76, 175, 80, 0.1);
  border-left: 3px solid #4caf50;
}

/* Tarjetas de información */
.info-card, .courts-card {
  margin-bottom: 16px;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  background-color: #1c1c1c;
  color: white;
  padding: 16px;
}

/* Encabezado de las tarjetas */
.info-card h2, .courts-card h2 {
  font-size: 20px;
  color: #ffffff;
}

/* Elementos dentro de las tarjetas */
.info-card p, .courts-card p {
  font-size: 14px;
  color: #dddddd;
  margin: 0;
}

/* Barra de búsqueda */
ion-searchbar {
  margin: 16px 0;
}

/* Lista de usuarios */
ion-list {
  background: none;
}

ion-item {
  --background: #1c1c1c;
  --color: white;
  --border-color: rgba(255, 255, 255, 0.1);
  --padding-start: 16px;
}



ion-item h2 {
  font-size: 16px;
  color: white;
}

ion-item p {
  font-size: 14px;
  color: #cccccc;
}

/* Estilo para el avatar */
.avatar-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #0066cc;
  color: white;
  font-size: 18px;
  font-weight: bold;
}

/* Badge de socio */
.member-badge {
  margin-top: 4px;
  --background: rgba(76, 175, 80, 0.2);
  --color: #4caf50;
}

/* Chips de roles */
ion-chip {
  font-size: 14px;
  color: white;
  border-radius: 8px;
}

ion-chip[color="success"] {
  --background: rgba(97, 76, 175, 0.2);
  --color: #4caf50;
}

ion-chip[color="danger"] {
  --background: rgba(244, 67, 54, 0.2);
}

ion-chip[color="warning"] {
  --background: rgba(255, 152, 0, 0.2);
  --color: #ff9800;
}

ion-chip[color="medium"] {
  --background: rgba(158, 158, 158, 0.2);
  --color: #9e9e9e;
}


ion-item ion-button ion-icon {
  font-size: 24px;
}

/* Estilos para cuando no hay usuarios */
.no-courts {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  text-align: center;
}

.no-courts ion-icon {
  font-size: 56px;
  color: #ffffff;
  margin-bottom: 16px;
}

.no-courts p {
  font-size: 18px;
  margin-bottom: 20px;
  color: #ffffff;
}

.no-courts ion-button {
  --background: transparent;
  --color: white;
  --box-shadow: none;
  max-width: 200px;
  margin: 0 auto;
}

.no-courts ion-button ion-icon {
  font-size: 50px;
  color: white;
  margin: 0;
}

/* Toast */
ion-toast {
  --background: #222222;
  --color: white;
  --button-color: #3880ff;
}

/* Alerta */
ion-alert {
  --background: #1c1c1c;
  --color: white;
  --header-color: #3880ff;
}

/* Responsive */
@media (max-width: 576px) {
  ion-card {
    padding: 12px;
  }

  ion-item h2 {
    font-size: 14px;
  }

  ion-item p {
    font-size: 12px;
  }
}
</file>

<file path="src/pages/Profile.tsx">
// src/pages/Profile.tsx
import React, { useState, useEffect } from 'react';
import {
  IonContent,
  IonHeader,
  IonPage,
  IonTitle,
  IonToolbar,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardTitle,
  IonItem,
  IonLabel,
  IonInput,
  IonButton,
  IonBackButton,
  IonButtons,
  IonLoading,
  IonToast,
  IonIcon,
  IonAvatar,
  IonText,
  IonGrid,
  IonRow,
  IonCol,
  IonAlert
} from '@ionic/react';
import { personCircleOutline, saveOutline, refreshOutline, mailOutline, callOutline, keyOutline, imageOutline } from 'ionicons/icons';
import { useAuth } from '../context/AuthContext';
import { useHistory } from 'react-router-dom';
import apiService from '../services/api.service';
import { API_ENDPOINTS } from '../utils/constants';
import './css/Profile.css';

const Profile: React.FC = () => {
  const { user, isLoading: authLoading, refreshUser } = useAuth();
  const history = useHistory();
  
  const [formData, setFormData] = useState({
    nombre: '',
    apellidos: '',
    email: '',
    telefono: '',
    bio: '',
    avatar_url: '',
    currentPassword: '',
    newPassword: '',
    confirmPassword: '',
  });

  // Nuevo estado para la URL de avatar temporal
  const [tempAvatarUrl, setTempAvatarUrl] = useState('');
  const [showAvatarAlert, setShowAvatarAlert] = useState(false);
  
  const [isEditing, setIsEditing] = useState(false);
  const [isChangingPassword, setIsChangingPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [successMessage, setSuccessMessage] = useState('');
  const [errorMessage, setErrorMessage] = useState('');
  
  // Cargar datos del usuario cuando el componente se monta
  useEffect(() => {
    if (user) {
      setFormData({
        ...formData,
        nombre: user.nombre || '',
        apellidos: user.apellidos || '',
        email: user.email || '',
        telefono: user.telefono || '',
        bio: user.bio || '',
        avatar_url: user.avatar_url || '',
        currentPassword: '',
        newPassword: '',
        confirmPassword: '',
      });
      
      // También establecer la URL temporal de avatar
      setTempAvatarUrl(user.avatar_url || '');
    }
  }, [user]);
  
  const handleInputChange = (e: CustomEvent, fieldName: string) => {
    const value = e.detail.value;
    setFormData(prevState => ({
      ...prevState,
      [fieldName]: value
    }));
  };
  
  const handleEditProfile = () => {
    setIsEditing(true);
    setIsChangingPassword(false);
  };
  
  const handleChangePassword = () => {
    setIsChangingPassword(true);
    setIsEditing(false);
  };
  
  const handleCancel = () => {
    // Restaurar datos originales
    if (user) {
      setFormData({
        ...formData,
        nombre: user.nombre || '',
        apellidos: user.apellidos || '',
        email: user.email || '',
        telefono: user.telefono || '',
        bio: user.bio || '',
        avatar_url: user.avatar_url || '',
        currentPassword: '',
        newPassword: '',
        confirmPassword: '',
      });
      
      // Restaurar URL temporal de avatar
      setTempAvatarUrl(user.avatar_url || '');
    }
    setIsEditing(false);
    setIsChangingPassword(false);
    setErrorMessage('');
  };

  // Función para manejar la actualización del avatar
  const handleAvatarUpdate = () => {
    setShowAvatarAlert(true);
  };

  // Función para aplicar URL de avatar temporal
  const applyAvatarUrl = () => {
    setFormData(prevState => ({
      ...prevState,
      avatar_url: tempAvatarUrl
    }));
    setShowAvatarAlert(false);
  };
  
  const handleUpdateProfile = async () => {
    if (!user) return;
    
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Preparar datos para actualizar
      const updateData = {
        nombre: formData.nombre,
        apellidos: formData.apellidos,
        email: formData.email,
        telefono: formData.telefono,
        bio: formData.bio,
        avatar_url: formData.avatar_url
      };
      
      // Llamar a la API para actualizar el perfil
      await apiService.put(`${API_ENDPOINTS.USER}/${user.id}`, updateData);
      
      setSuccessMessage('Perfil actualizado correctamente');
      setIsEditing(false);
      
      // Recargar los datos del usuario
      await refreshUser();
      
      setTimeout(() => {
        setSuccessMessage('');
      }, 3000);
    } catch (error: any) {
      console.error('Error al actualizar perfil:', error);
      setErrorMessage(error.message || 'Error al actualizar el perfil');
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleUpdatePassword = async () => {
    if (!user) return;
    
    // Validar que las contraseñas coincidan
    if (formData.newPassword !== formData.confirmPassword) {
      setErrorMessage('Las contraseñas no coinciden');
      return;
    }
    
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Preparar datos para actualizar la contraseña
      const passwordData = {
        user_id: user.id,
        current_password: formData.currentPassword,
        new_password: formData.newPassword
      };
      
      // Llamar a la API para actualizar la contraseña
      await apiService.put(API_ENDPOINTS.UPDATE_PASSWORD, passwordData);
      
      setSuccessMessage('Contraseña actualizada correctamente');
      setIsChangingPassword(false);
      
      // Limpiar campos de contraseña
      setFormData(prevState => ({
        ...prevState,
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
      }));
      
      setTimeout(() => {
        setSuccessMessage('');
      }, 3000);
    } catch (error: any) {
      console.error('Error al actualizar contraseña:', error);
      
      let errorMsg = 'Error al actualizar la contraseña';
      if (error.message) {
        errorMsg = error.message;
      }
      
      setErrorMessage(errorMsg);
    } finally {
      setIsLoading(false);
    }
  };

  // Función para validar URL de imagen
  const validateImageUrl = (url: string) => {
    // URL vacía es permitida
    if (!url) return true;
    
    // Validación básica: debe iniciar con http:// o https://
    return url.startsWith('http://') || url.startsWith('https://');
  };
  
  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/home" />
          </IonButtons>
          <IonTitle>Mi Perfil</IonTitle>
        </IonToolbar>
      </IonHeader>
      <IonContent className="profile-container">
        {authLoading ? (
          <IonLoading isOpen={true} message="Cargando perfil..." />
        ) : user ? (
          <>
            <div className="profile-header">
              <IonAvatar className="profile-avatar" onClick={isEditing ? handleAvatarUpdate : undefined}>
                {tempAvatarUrl ? (
                  <img src={tempAvatarUrl} alt={user.nombre} />
                ) : (
                  <IonIcon icon={personCircleOutline} size="large" />
                )}
              </IonAvatar>
              {isEditing && (
                <IonText color="light" className="edit-avatar-text">
                  <p><small>Toca para cambiar avatar</small></p>
                </IonText>
              )}
              <h2 className="profile-name">{user.nombre} {user.apellidos}</h2>
              <p>{user.email}</p>
            </div>
            
            <IonCard className="profile-card">
              {!isEditing && !isChangingPassword && (
                <>
                  <IonCardHeader>
                    <IonCardTitle>Información Personal</IonCardTitle>
                  </IonCardHeader>
                  <IonCardContent>
                    <IonItem>
                      <IonLabel>
                        <h2>Nombre</h2>
                        <p>{user.nombre} {user.apellidos}</p>
                      </IonLabel>
                    </IonItem>
                    <IonItem>
                      <IonLabel>
                        <h2>Email</h2>
                        <p>{user.email}</p>
                      </IonLabel>
                    </IonItem>
                    <IonItem>
                      <IonLabel>
                        <h2>Teléfono</h2>
                        <p>{user.telefono || 'No disponible'}</p>
                      </IonLabel>
                    </IonItem>
                    <IonItem lines="none">
                      <IonLabel>
                        <h2>Biografía</h2>
                        <p>{formData.bio || 'No hay información disponible'}</p>
                      </IonLabel>
                    </IonItem>
                    
                    <IonGrid>
                      <IonRow>
                        <IonCol>
                          <IonButton expand="block" onClick={handleEditProfile}>
                            Editar Perfil
                          </IonButton>
                        </IonCol>
                        <IonCol>
                          <IonButton expand="block" color="secondary" onClick={handleChangePassword}>
                            Cambiar Contraseña
                          </IonButton>
                        </IonCol>
                      </IonRow>
                    </IonGrid>
                  </IonCardContent>
                </>
              )}
              
              {isEditing && (
                <>
                  <IonCardHeader>
                    <IonCardTitle>Editar Perfil</IonCardTitle>
                  </IonCardHeader>
                  <IonCardContent>
                    <form className="profile-form">
                      <IonItem>
                        <IonLabel position="floating">Nombre</IonLabel>
                        <IonInput
                          value={formData.nombre}
                          onIonChange={(e) => handleInputChange(e, 'nombre')}
                          required
                        />
                      </IonItem>
                      <IonItem>
                        <IonLabel position="floating">Apellidos</IonLabel>
                        <IonInput
                          value={formData.apellidos}
                          onIonChange={(e) => handleInputChange(e, 'apellidos')}
                          required
                        />
                      </IonItem>
                      <IonItem>
                        <IonLabel position="floating">Email</IonLabel>
                        <IonInput
                          type="email"
                          value={formData.email}
                          onIonChange={(e) => handleInputChange(e, 'email')}
                          required
                        />
                      </IonItem>
                      <IonItem>
                        <IonLabel position="floating">Teléfono</IonLabel>
                        <IonInput
                          type="tel"
                          value={formData.telefono}
                          onIonChange={(e) => handleInputChange(e, 'telefono')}
                        />
                      </IonItem>
                      <IonItem>
                        <IonLabel position="floating">Biografía</IonLabel>
                        <IonInput
                          value={formData.bio}
                          onIonChange={(e) => handleInputChange(e, 'bio')}
                        />
                      </IonItem>
                      
                      <div className="form-buttons">
                        <IonButton color="medium" onClick={handleCancel}>
                          Cancelar
                        </IonButton>
                        <IonButton onClick={handleUpdateProfile}>
                          <IonIcon slot="start" icon={saveOutline} />
                          Guardar Cambios
                        </IonButton>
                      </div>
                    </form>
                  </IonCardContent>
                </>
              )}
              
              {isChangingPassword && (
                <>
                  <IonCardHeader>
                    <IonCardTitle>Cambiar Contraseña</IonCardTitle>
                  </IonCardHeader>
                  <IonCardContent>
                    <form className="profile-form">
                      <IonItem>
                        <IonLabel position="floating">Contraseña Actual</IonLabel>
                        <IonInput
                          type="password"
                          value={formData.currentPassword}
                          onIonChange={(e) => handleInputChange(e, 'currentPassword')}
                          required
                        />
                      </IonItem>
                      <IonItem>
                        <IonLabel position="floating">Nueva Contraseña</IonLabel>
                        <IonInput
                          type="password"
                          value={formData.newPassword}
                          onIonChange={(e) => handleInputChange(e, 'newPassword')}
                          required
                        />
                      </IonItem>
                      <IonItem>
                        <IonLabel position="floating">Confirmar Contraseña</IonLabel>
                        <IonInput
                          type="password"
                          value={formData.confirmPassword}
                          onIonChange={(e) => handleInputChange(e, 'confirmPassword')}
                          required
                        />
                      </IonItem>
                      
                      <div className="form-buttons">
                        <IonButton color="medium" onClick={handleCancel}>
                          Cancelar
                        </IonButton>
                        <IonButton onClick={handleUpdatePassword}>
                          <IonIcon slot="start" icon={saveOutline} />
                          Actualizar Contraseña
                        </IonButton>
                      </div>
                    </form>
                  </IonCardContent>
                </>
              )}
            </IonCard>
            
            {successMessage && (
              <div className="success-message">
                <IonText color="success">
                  {successMessage}
                </IonText>
              </div>
            )}
            
            {errorMessage && (
              <div className="error-message">
                <IonText color="danger">
                  {errorMessage}
                </IonText>
              </div>
            )}

            {/* Alerta para cambiar avatar */}
            <IonAlert
              isOpen={showAvatarAlert}
              onDidDismiss={() => setShowAvatarAlert(false)}
              header="Cambiar avatar"
              subHeader="Introduce la URL de la imagen"
              inputs={[
                {
                  name: 'avatar_url',
                  type: 'url',
                  placeholder: 'https://ejemplo.com/imagen.jpg',
                  value: tempAvatarUrl
                }
              ]}
              buttons={[
                {
                  text: 'Cancelar',
                  role: 'cancel'
                },
                {
                  text: 'Ver previa',
                  handler: (data) => {
                    if (validateImageUrl(data.avatar_url)) {
                      setTempAvatarUrl(data.avatar_url);
                      return false; // Mantener el diálogo abierto
                    } else {
                      setErrorMessage('URL de imagen no válida. Debe comenzar con http:// o https://');
                      return false;
                    }
                  }
                },
                {
                  text: 'Guardar',
                  handler: (data) => {
                    if (validateImageUrl(data.avatar_url)) {
                      setTempAvatarUrl(data.avatar_url);
                      applyAvatarUrl();
                      return true;
                    } else {
                      setErrorMessage('URL de imagen no válida. Debe comenzar con http:// o https://');
                      return false;
                    }
                  }
                }
              ]}
            />
          </>
        ) : (
          <div className="ion-padding ion-text-center">
            <IonText color="medium">
              <p>No se pudo cargar la información del usuario.</p>
            </IonText>
            <IonButton onClick={() => window.location.reload()}>
              <IonIcon slot="start" icon={refreshOutline} />
              Recargar
            </IonButton>
          </div>
        )}
        
        <IonLoading isOpen={isLoading} message="Procesando..." />
      </IonContent>
    </IonPage>
  );
};

export default Profile;
</file>

<file path="src/services/api.service.ts">
// src/services/api.service.ts
import { API_URL } from '../utils/constants';

class ApiService {
  async get(endpoint: string, token?: string) {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    try {
      const response = await fetch(`${API_URL}${endpoint}`, {
        method: 'GET',
        headers
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
      
        throw new Error(errorData.error || `Error: ${response.status}`);
      }
      
      const data = await response.json();
      return data;
    } catch (error: any) {
      console.error(`Error completo en API GET ${endpoint}:`, error);
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error(`Error en la solicitud GET a ${endpoint}`);
    }
  }
  
  async post(endpoint: string, data: any, token?: string) {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    try {
      const response = await fetch(`${API_URL}${endpoint}`, {
        method: 'POST',
        headers,
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
        console.error('Error en respuesta API POST:', errorData);
        throw new Error(errorData.error || `Error: ${response.status}`);
      }
      
      const responseData = await response.json();
      return responseData;
    } catch (error: any) {
      console.error(`Error completo en API POST ${endpoint}:`, error);
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error(`Error en la solicitud POST a ${endpoint}`);
    }
  }
  
  async put(endpoint: string, data: any, token?: string) {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    try {
      const response = await fetch(`${API_URL}${endpoint}`, {
        method: 'PUT',
        headers,
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
        console.error('Error en respuesta API PUT:', errorData);
        throw new Error(errorData.error || `Error: ${response.status}`);
      }
      
      const responseData = await response.json();
      return responseData;
    } catch (error: any) {
      console.error(`Error completo en API PUT ${endpoint}:`, error);
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error(`Error en la solicitud PUT a ${endpoint}`);
    }
  }
  
  async delete(endpoint: string, token?: string) {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    try {
      const response = await fetch(`${API_URL}${endpoint}`, {
        method: 'DELETE',
        headers
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
        console.error('Error en respuesta API DELETE:', errorData);
        throw new Error(errorData.error || `Error: ${response.status}`);
      }
      
      const responseData = await response.json();
      return responseData;
    } catch (error: any) {
      console.error(`Error completo en API DELETE ${endpoint}:`, error);
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error(`Error en la solicitud DELETE a ${endpoint}`);
    }
  }
}

export default new ApiService();
</file>

<file path="src/pages/ManageUsers.tsx">
import React, { useState, useEffect } from 'react';
import {
  IonContent,
  IonHeader,
  IonPage,
  IonTitle,
  IonToolbar,
  IonButtons,
  IonBackButton,
  IonGrid,
  IonRow,
  IonCol,
  IonCard,
  IonCardHeader,
  IonCardTitle,
  IonCardContent,
  IonItem,
  IonLabel,
  IonButton,
  IonIcon,
  IonList,
  IonLoading,
  IonToast,
  IonText,
  IonSearchbar,
  IonChip,
  IonRefresher,
  IonRefresherContent,
  IonAlert,
  IonBadge,
  IonAvatar
} from '@ionic/react';
import { 
  personAddOutline,
  personRemoveOutline,
  refreshOutline,
  personCircleOutline,
  shieldOutline
} from 'ionicons/icons';
import { useAuth } from '../context/AuthContext';
import { useHistory } from 'react-router-dom';
import apiService from '../services/api.service';
import './css/ManageUsers.css';

const ManageUsers: React.FC = () => {
  const { user } = useAuth();
  const history = useHistory();
  
  // Estados
  const [clubId, setClubId] = useState<number | null>(null);
  const [clubData, setClubData] = useState<any>(null);
  const [users, setUsers] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [showToast, setShowToast] = useState<boolean>(false);
  const [toastMessage, setToastMessage] = useState<string>('');
  const [toastColor, setToastColor] = useState<string>('success');
  const [searchText, setSearchText] = useState<string>('');
  const [showAlert, setShowAlert] = useState<boolean>(false);
  const [alertMessage, setAlertMessage] = useState<string>('');
  const [selectedUserId, setSelectedUserId] = useState<number | null>(null);
  const [alertAction, setAlertAction] = useState<'add' | 'remove'>('add');
  


  // Obtener rol como texto
  const getRolName = (rolId: number): string => {
    switch (rolId) {
      case 1: return 'ADMIN';
      case 2: return 'PROFESOR';
      case 3: return 'EMPLEADO';
      case 4: return 'USUARIO';
      case 5: return 'SOCIO';
      default: return 'DESCONOCIDO';
    }
  };

  // Obtener color según rol
  const getRolColor = (rolId: number): string => {
    switch (rolId) {
      case 1: return 'danger';
      case 2: return 'secondary';
      case 3: return 'tertiary';
      case 4: return 'medium';
      case 5: return 'success';
      default: return 'medium';
    }
  };

  // Función para obtener el número total de socios
  const getTotalMembers = (): number => {
    if (!clubId) return 0;
    return users.filter(u => isUserMember(u.id)).length;
  };

  // Mostrar mensaje de toast
  const showToastMessage = (message: string, color: string = 'success') => {
    setToastMessage(message);
    setToastColor(color);
    setShowToast(true);
  };
  
  // Verificar si el usuario ya es socio
  const isUserMember = (userId: number): boolean => {
    const userFound = users.find(u => u.id === userId);
    
    if (userFound && userFound.club_socio && userFound.id_rol === 5) {
      return userFound.club_socio.id === clubId;
    }
    
    return Boolean(userFound && userFound.id_rol === 5 && userFound.id_club_socio === clubId);
  };
  
  // Verificar si un usuario es administrador
  const isUserAdmin = (userId: number): boolean => {
    const userFound = users.find(u => u.id === userId);
    if (!userFound) return false;
    
    return userFound.id_rol === 1;
  };
  
  // Verificar si un usuario es administrador de este club específico
  const isClubAdmin = (userId: number): boolean => {
    if (!clubData) return false;
    const userFound = users.find(u => u.id === userId);
    if (!userFound || userFound.id_rol !== 1) return false;
    
    return clubData.id_administrador === userId;
  };
  
  // Verificar si un usuario es miembro de algún club
  const isMemberOfAnyClub = (userId: number): boolean => {
    const userFound = users.find(u => u.id === userId);
    
    if (!userFound) return false;
    
    if (userFound.id_rol === 5) {
      if (userFound.club_socio) {
        return true;
      }
      
      if (userFound.id_club_socio) {
        return true;
      }
    }
    
    return false;
  };
  
  // Verificar si un usuario pertenece a este club
  const belongsToThisClub = (user: any): boolean => {
    if (!clubId || !clubData) return false;
    
    // Es el administrador de este club
    if (user.id_rol === 1 && clubData.id_administrador === user.id) {
      return true;
    }
    
    // Es profesor o empleado de este club
    if ((user.id_rol === 2 || user.id_rol === 3) && user.id_club === clubId) {
      return true;
    }
    
    // Es socio de este club
    if (user.id_rol === 5) {
      if (user.club_socio && user.club_socio.id === clubId) {
        return true;
      }
      if (user.id_club_socio === clubId) {
        return true;
      }
    }
    
    // Es un usuario regular (sin club asignado)
    if (user.id_rol === 4 && !isMemberOfAnyClub(user.id)) {
      return true;
    }
    
    return false;
  };
  
  // Filtrar usuarios con búsqueda común
  const applySearchFilter = (userList: any[]) => {
    return userList.filter(user => {
      const fullName = `${user.nombre} ${user.apellidos}`.toLowerCase();
      return fullName.includes(searchText.toLowerCase()) || 
             user.email.toLowerCase().includes(searchText.toLowerCase());
    });
  };

  // Obtener todos los usuarios relacionados con este club
  const getClubRelatedUsers = () => {
    return users.filter(user => belongsToThisClub(user));
  };

  // Filtrar usuarios para el personal del club (ADMIN, PROFESOR, EMPLEADO)
  const filteredStaffUsers = applySearchFilter(getClubRelatedUsers()).filter(user => {
    // Solo mostrar usuarios con roles 1 (ADMIN), 2 (PROFESOR) o 3 (EMPLEADO)
    // Y que estén relacionados con este club específico
    return [1, 2, 3].includes(user.id_rol);
  });
  
  // Filtrar usuarios para la sección de usuarios (USUARIO, SOCIO)
  const filteredRegularUsers = applySearchFilter(getClubRelatedUsers()).filter(user => {
    // Solo mostrar usuarios con roles 4 (USUARIO) o 5 (SOCIO)
    return [4, 5].includes(user.id_rol);
  });
  
  // Cargar datos del club y usuarios
  useEffect(() => {
    const loadClubData = async () => {
      if (!user || user.id_rol !== 1) {
        // Redirigir si no es administrador
        history.replace('/home');
        return;
      }
      
      try {
        setLoading(true);
        // Buscar club por id_administrador
        const clubsResponse = await apiService.get(`/clubs?id_administrador=${user.id}`);
        
        if (clubsResponse && clubsResponse.length > 0) {
          const club = clubsResponse[0];
          setClubId(club.id);
          setClubData(club);
          
          // Cargar usuarios
          await loadUsers();
        } else {
          showToastMessage('No se encontró información del club', 'warning');
        }
      } catch (error) {
        console.error('Error al cargar datos:', error);
        showToastMessage('Error al cargar datos del club', 'danger');
      } finally {
        setLoading(false);
      }
    };
    
    loadClubData();
  }, [user, history]);
  
  // Cargar usuarios
  const loadUsers = async () => {
    try {
      setLoading(true);
      const usersResponse = await apiService.get('/users');
      
      if (Array.isArray(usersResponse)) {
        setUsers(usersResponse);
      } else {
        setUsers([]);
      }
    } catch (error) {
      console.error('Error al cargar usuarios:', error);
      showToastMessage('Error al cargar usuarios', 'danger');
    } finally {
      setLoading(false);
    }
  };
  
  // Handle refresh
  const handleRefresh = async (event: CustomEvent) => {
    try {
      await loadUsers();
    } finally {
      event.detail.complete();
    }
  };
  
  const prepareAddAsMember = (userId: number) => {
    // Verificar si el usuario es administrador
    if (isUserAdmin(userId)) {
      showToastMessage('No se puede modificar el rol de un administrador', 'danger');
      return;
    }
    
    if (isUserMember(userId)) {
      showToastMessage('Este usuario ya es socio del club', 'warning');
      return;
    }
  
    setSelectedUserId(userId);
    setAlertAction('add');
    
    const selectedUser = users.find(u => u.id === userId);
    const userName = selectedUser ? `${selectedUser.nombre} ${selectedUser.apellidos}` : 'este usuario';
    
    setAlertMessage(`¿Añadir a ${userName} como socio del club?`);
    setShowAlert(true);
  };
  
  // Comprobación para quitar un usuario como socio
  const prepareRemoveAsMember = (userId: number) => {
    // Verificar si el usuario es administrador
    if (isUserAdmin(userId)) {
      showToastMessage('No se puede modificar el rol de un administrador', 'danger');
      return;
    }
    
    // Verificar si el usuario es socio
    if (!isUserMember(userId)) {
      showToastMessage('Este usuario no es socio del club', 'warning');
      return;
    }
    
    setSelectedUserId(userId);
    setAlertAction('remove');
    
    // Buscar información del usuario para mostrar en el mensaje
    const selectedUser = users.find(u => u.id === userId);
    const userName = selectedUser ? `${selectedUser.nombre} ${selectedUser.apellidos}` : 'este usuario';
    
    setAlertMessage(`¿Eliminar a ${userName} como socio del club?`);
    setShowAlert(true);
  };
  
  const confirmAction = async () => {
    if (!selectedUserId || !clubId) return;
    
    if (alertAction === 'add') {
      await addAsMember(selectedUserId);
    } else {
      await removeAsMember(selectedUserId);
    }
    
    setShowAlert(false);
  };
  
  // Añadir usuario como socio del club
  const addAsMember = async (userId: number) => {
    if (!clubId) {
      showToastMessage('No se ha seleccionado un club', 'danger');
      return;
    }
    
    try {
      setLoading(true);
      
      if (isUserAdmin(userId)) {
        showToastMessage('No se puede modificar el rol de un administrador', 'danger');
        return;
      }
      
      // Verificar si el usuario ya es socio
      if (isUserMember(userId)) {
        showToastMessage('Este usuario ya es socio del club', 'warning');
        setLoading(false);
        return;
      }
      
      const response = await apiService.post('/add-club-member', {
        user_id: userId,
        club_id: clubId
      });
      
      
      const updatedUsers = users.map(u => {
        if (u.id === userId) {
          return { ...u, id_rol: 5, id_club_socio: clubId };
        }
        return u;
      });
      
      setUsers(updatedUsers);
      showToastMessage('Usuario añadido como socio correctamente', 'success');
      
      // Recargar lista de usuarios después de una pausa
      setTimeout(async () => {
        await loadUsers();
      }, 1000);
      
    } catch (error) {
      console.error('Error al añadir socio:', error);
      showToastMessage('Error al añadir usuario como socio', 'danger');
    } finally {
      setLoading(false);
    }
  };
  
  // Eliminar usuario como socio del club
  const removeAsMember = async (userId: number) => {
    if (!clubId) {
      showToastMessage('No se ha seleccionado un club', 'danger');
      return;
    }
    
    try {
      setLoading(true);
      
      // Buscar al usuario
      const userToUpdate = users.find(u => u.id === userId);
      if (!userToUpdate) {
        showToastMessage('Usuario no encontrado', 'danger');
        return;
      }
      
      // Verificar que el usuario no sea socio
      if (!isUserMember(userId)) {
        showToastMessage('Este usuario no es socio del club', 'warning');
        return;
      }
      
      // Usar endpoint para quitar de socio a un usuario
      try {
        const response = await apiService.post('/remove-club-member', {
          user_id: userId,
          club_id: clubId
        });
      } catch (error) {
        // En caso de error, cambiar rol a usuario 
        const updateData = {
          id_rol: 4,
          id_club_socio: null
        };
      }
      showToastMessage('Usuario eliminado como socio correctamente', 'success');
      
      // Recargar lista de usuarios
      await loadUsers();
      
    } catch (error) {
      console.error('Error al eliminar socio:');
      showToastMessage('Error al eliminar usuario como socio', 'danger');
    } finally {
      setLoading(false);
    }
  };

  // Renderizar lista de usuarios
  const renderUserList = (userList: any[], showHeader: boolean = true) => {
    if (userList.length === 0) {
      return (
        <div className="no-courts">
          <IonIcon icon={personCircleOutline} className="empty-icon" />
          <IonText color="medium" className="empty-text">
            <p>No se encontraron usuarios</p>
          </IonText>
          <IonButton 
            className="refresh-button"
            expand="block" 
            fill="clear"
            onClick={() => loadUsers()}
          >
            <IonIcon slot="icon-only" icon={refreshOutline} />
          </IonButton>
        </div>
      );
    }
    
    return (
      <IonList>
        {userList.map((userData) => {
          const userIsMember = isUserMember(userData.id);
          const userIsAdmin = isUserAdmin(userData.id);
          
          return (
            <IonItem 
              key={userData.id} 
              className={`${userIsMember ? 'member-item' : ''} ${userIsAdmin ? 'admin-item' : ''}`}
            >
              <IonAvatar slot="start">
                {userData.avatar_url ? (
                  <img src={userData.avatar_url} alt={userData.nombre} />
                ) : (
                  <div className="avatar-placeholder">
                    {userData.nombre.charAt(0)}
                  </div>
                )}
              </IonAvatar>
              
              <IonLabel>
                <h2>{userData.nombre} {userData.apellidos}</h2>
                <p>{userData.email}</p>
              </IonLabel>
              
              <IonChip 
                color={getRolColor(userData.id_rol)} 
                slot="end"
              >
                {getRolName(userData.id_rol)}
              </IonChip>
              
              {/* Solo mostrar botones si no es administrador */}
              {!userIsAdmin && userData.id_rol === 4 && (
                <>
                  {/* Botón para añadir como socio */}
                  <IonButton 
                    slot="end" 
                    fill="clear" 
                    color="success"
                    onClick={() => prepareAddAsMember(userData.id)}
                  >
                    <IonIcon slot="icon-only" icon={personAddOutline} />
                  </IonButton>
                </>
              )}
              
              {/* Solo mostrar botón de quitar para socios */}
              {!userIsAdmin && userData.id_rol === 5 && (
                <>
                  {/* Botón para quitar como socio */}
                  <IonButton 
                    slot="end" 
                    fill="clear" 
                    color="danger"
                    onClick={() => prepareRemoveAsMember(userData.id)}
                  >
                    <IonIcon slot="icon-only" icon={personRemoveOutline} />
                  </IonButton>
                </>
              )}
            </IonItem>
          );
        })}
      </IonList>
    );
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/home" />
          </IonButtons>
          <IonTitle>Gestión de Usuarios</IonTitle>
          <IonButtons slot="end">
            <IonButton onClick={loadUsers}>
              <IonIcon slot="icon-only" icon={refreshOutline} />
            </IonButton>
          </IonButtons>
        </IonToolbar>
      </IonHeader>
      
      <IonContent>
      <div className="background-container"></div>
        <IonRefresher slot="fixed" onIonRefresh={handleRefresh}>
          <IonRefresherContent></IonRefresherContent>
        </IonRefresher>
        
        <IonGrid>
          <IonRow>
            <IonCol size="12" sizeMd="8" offsetMd="2">
              <IonCard className="info-card">
                <IonCardHeader>
                  <IonCardTitle>
                    {clubData ? clubData.nombre : 'Club'}
                    <IonBadge color="success" style={{ float: 'right' }}>
                       Nº Socios: {getTotalMembers()}
                    </IonBadge>
                  </IonCardTitle>
                </IonCardHeader>
                <IonCardContent>
                  <p>
                    Administre los usuarios de su club. Puede añadir socios, gestionar membresías y administrar usuarios.
                  </p>
                </IonCardContent>
              </IonCard>
              
              <IonSearchbar
                value={searchText}
                onIonChange={e => setSearchText(e.detail.value || '')}
                placeholder="Buscar usuarios..."
              />
              
              <IonCard className="courts-card">
                <IonCardHeader>
                  <IonCardTitle>Personal del club</IonCardTitle>
                </IonCardHeader>
                <IonCardContent>
                  {renderUserList(filteredStaffUsers)}
                </IonCardContent>
              </IonCard>

              <IonCard className="courts-card">
                <IonCardHeader>
                  <IonCardTitle>Usuarios</IonCardTitle>
                </IonCardHeader>
                <IonCardContent>
                  {renderUserList(filteredRegularUsers)}
                </IonCardContent>
              </IonCard>
            </IonCol>
          </IonRow>
        </IonGrid>
        
        {/* Alerta de confirmación */}
        <IonAlert
          isOpen={showAlert}
          onDidDismiss={() => setShowAlert(false)}
          header={alertAction === 'add' ? "Añadir socio" : "Eliminar socio"}
          message={alertMessage}
          buttons={[
            {
              text: 'Cancelar',
              role: 'cancel',
              cssClass: 'secondary'
            },
            {
              text: 'Confirmar',
              handler: confirmAction
            }
          ]}
        />
        
        <IonLoading isOpen={loading} message="Cargando usuarios..." />
        
        <IonToast
          isOpen={showToast}
          onDidDismiss={() => setShowToast(false)}
          message={toastMessage}
          duration={2000}
          position="bottom"
          color={toastColor}
        />
      </IonContent>
    </IonPage>
  );
};

export default ManageUsers;
</file>

<file path="src/pages/Reservas.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { 
  IonContent, 
  IonPage,
  IonButton,
  IonItem,
  IonLabel,
  IonSelect,
  IonSelectOption,
  IonTextarea,
  IonDatetime,
  IonLoading,
  IonToast,
  IonIcon,
  IonPopover,
  IonHeader,
  IonToolbar,
  IonTitle,
  IonButtons,
  IonBackButton,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardTitle,
  IonGrid,
  IonRow,
  IonCol,
  IonText
} from '@ionic/react';
import { 
  tennisballOutline,
  calendarOutline,
  timeOutline,
  businessOutline,
  locationOutline,
  cashOutline
} from 'ionicons/icons';
import { useAuth } from '../context/AuthContext';
import { useHistory } from 'react-router';
import apiService from '../services/api.service';
import './css/Reservas.css';

interface FranjaHoraria {
  inicio: string;
  fin: string;
  seleccionada: boolean;
}

interface RangoHorario {
  inicio: string;
  fin: string;
}

const ReservarPista: React.FC = () => {
  const { user } = useAuth();
  const history = useHistory();
  const fechaSelectorRef = useRef<HTMLDivElement>(null);
  
  // Estados para los datos de la reserva
  const [clubes, setClubes] = useState<any[]>([]);
  const [pistas, setPistas] = useState<any[]>([]);
  const [clubSeleccionado, setClubSeleccionado] = useState<number | null>(null);
  const [clubDatos, setClubDatos] = useState<any>(null);
  const [pistaSeleccionada, setPistaSeleccionada] = useState<number | null>(null);
  const [pistaDatos, setPistaDatos] = useState<any>(null);
  const [fechaSeleccionada, setFechaSeleccionada] = useState<string>('');
  const [horasDisponibles, setHorasDisponibles] = useState<FranjaHoraria[]>([]);
  const [franjasSeleccionadas, setFranjasSeleccionadas] = useState<FranjaHoraria[]>([]);
  const [rangosHorarios, setRangosHorarios] = useState<RangoHorario[]>([]);
  const [precioTotal, setPrecioTotal] = useState<number>(0);
  const [tarifaTotal, setTarifaTotal] = useState<number>(0);
  const [notas, setNotas] = useState<string>('');
  const [isDateTimeOpen, setIsDateTimeOpen] = useState<boolean>(false);
  
  // Estados para UI
  const [cargando, setCargando] = useState<boolean>(false);
  const [mostrarToast, setMostrarToast] = useState<boolean>(false);
  const [mensajeToast, setMensajeToast] = useState<string>('');
  const [colorToast, setColorToast] = useState<string>('success');
  
  // Cargar clubes al iniciar
  useEffect(() => {
    cargarClubes();
  }, []);
  
  // Función para cargar clubes
  const cargarClubes = async () => {
    try {
      setCargando(true);
      const response = await apiService.get('/clubs');
      console.log("Clubes cargados:", response);
      setClubes(response);
    } catch (error) {
      console.error('Error al cargar clubes:', error);
      mostrarMensaje('Error al cargar los clubes', 'danger');
    } finally {
      setCargando(false);
    }
  };
  
  // Cargar pistas cuando se selecciona un club
  useEffect(() => {
    if (clubSeleccionado) {
      cargarPistas();
      
      // Obtener datos del club seleccionado
      const club = clubes.find(c => c.id === clubSeleccionado);
      setClubDatos(club);
    } else {
      setClubDatos(null);
    }
  }, [clubSeleccionado, clubes]);
  
  // Función para cargar pistas
  const cargarPistas = async () => {
    if (!clubSeleccionado) return;
    
    try {
      setCargando(true);
      const response = await apiService.get(`/clubs/${clubSeleccionado}/pistas`);
      console.log("Pistas cargadas:", response);
      setPistas(response);
    } catch (error) {
      console.error('Error al cargar pistas:', error);
      mostrarMensaje('Error al cargar las pistas', 'danger');
    } finally {
      setCargando(false);
    }
  };
  
  // Cargar datos de la pista seleccionada
  useEffect(() => {
    if (pistaSeleccionada) {
      const pistaInfo = pistas.find(p => p.id === pistaSeleccionada);
      console.log("Pista seleccionada:", pistaInfo);
      setPistaDatos(pistaInfo);
    } else {
      setPistaDatos(null);
    }
  }, [pistaSeleccionada, pistas]);
  
  // Actualizar precio cuando cambian las franjas seleccionadas o la pista
  useEffect(() => {
    calcularPrecioTotal();
  }, [franjasSeleccionadas, pistaDatos]);
  
  // Verificar disponibilidad cuando se selecciona fecha y pista
  useEffect(() => {
    if (pistaSeleccionada && fechaSeleccionada) {
      verificarDisponibilidad();
    }
  }, [pistaSeleccionada, fechaSeleccionada]);
  
  // Actualizar rangos horarios cuando cambian las franjas seleccionadas
  useEffect(() => {
    if (franjasSeleccionadas.length > 0) {
      const rangos = consolidarRangosHorarios(franjasSeleccionadas);
      setRangosHorarios(rangos);
    } else {
      setRangosHorarios([]);
    }
  }, [franjasSeleccionadas]);
  
  // Función para calcular el precio total basado en el número de franjas horarias
  const calcularPrecioTotal = () => {
    if (!pistaDatos || franjasSeleccionadas.length === 0) {
      setPrecioTotal(0);
      setTarifaTotal(0);
      return;
    }
    
    // Obtener el precio base de la pista
    const precioPista = pistaDatos.precio_hora;
    
    // Multiplicar por el número de franjas seleccionadas
    const numFranjas = franjasSeleccionadas.length;
    const precio = precioPista * numFranjas;
    
    console.log(`Calculando precio: ${precioPista}€ × ${numFranjas} franjas = ${precio}€`);
    
    setPrecioTotal(precio);
    setTarifaTotal(precio); // También actualizar la tarifa total
  };
  
  // Función para consolidar franjas horarias en rangos continuos
  const consolidarRangosHorarios = (franjas: FranjaHoraria[]): RangoHorario[] => {
    if (franjas.length === 0) return [];
    
    // Ordenar franjas por hora de inicio
    const franjasOrdenadas = [...franjas].sort((a, b) => a.inicio.localeCompare(b.inicio));
    
    const rangos: RangoHorario[] = [];
    let rangoActual: RangoHorario = {
      inicio: franjasOrdenadas[0].inicio,
      fin: franjasOrdenadas[0].fin
    };
    
    for (let i = 1; i < franjasOrdenadas.length; i++) {
      const franja = franjasOrdenadas[i];
      
      // Si esta franja comienza donde termina la anterior, extender el rango
      if (franja.inicio === rangoActual.fin) {
        rangoActual.fin = franja.fin;
      } else {
        // Si hay un hueco, guardar el rango actual y comenzar uno nuevo
        rangos.push({ ...rangoActual });
        rangoActual = {
          inicio: franja.inicio,
          fin: franja.fin
        };
      }
    }
    
    // Añadir el último rango
    rangos.push(rangoActual);
    
    return rangos;
  };
  
  // Función para verificar disponibilidad
  const verificarDisponibilidad = async () => {
    if (!pistaSeleccionada || !fechaSeleccionada) return;
    
    try {
      setCargando(true);
      const fechaFormateada = formatearFecha(fechaSeleccionada);
      
      // Obtener todas las reservas existentes para esta pista y fecha
      const reservasResponse = await apiService.get(`/reservas?id_pista=${pistaSeleccionada}&fecha=${fechaFormateada}`);
      console.log("Reservas existentes:", reservasResponse);
      const reservasExistentes = Array.isArray(reservasResponse) ? reservasResponse : [];
      
      // Obtener horario del club
      const disponibilidadResponse = await apiService.get(`/pistas/${pistaSeleccionada}/disponibilidad?fecha=${fechaFormateada}`);
      console.log("Disponibilidad:", disponibilidadResponse);
      
      if (disponibilidadResponse.disponible) {
        // Generar todas las franjas horarias fijas de 90 minutos
        const todasLasFranjas = generarFranjasFijas(
          disponibilidadResponse.horario_club.apertura, 
          disponibilidadResponse.horario_club.cierre
        );
        
        // Filtrar franjas ocupadas
        const franjasDisponibles = filtrarFranjasOcupadas(todasLasFranjas, reservasExistentes);
        
        console.log("Franjas disponibles:", franjasDisponibles);
        
        if (franjasDisponibles.length > 0) {
          setHorasDisponibles(franjasDisponibles);
          setFranjasSeleccionadas([]);  // Resetear selección al cambiar disponibilidad
          setRangosHorarios([]);
        } else {
          setHorasDisponibles([]);
          mostrarMensaje('No hay horarios disponibles para esta fecha', 'warning');
        }
      } else {
        setHorasDisponibles([]);
        mostrarMensaje('La pista no está disponible para esta fecha', 'warning');
      }
    } catch (error) {
      console.error('Error al verificar disponibilidad:', error);
      mostrarMensaje('Error al verificar disponibilidad', 'danger');
    } finally {
      setCargando(false);
    }
  };
  
  // Función para generar franjas horarias fijas de 90 minutos
  const generarFranjasFijas = (horaApertura: string, horaCierre: string): FranjaHoraria[] => {
    const franjas: FranjaHoraria[] = [];
    
    // Convertir a objetos Date para facilitar cálculos
    let horaActual = new Date(`2000-01-01T${horaApertura}`);
    const horaFin = new Date(`2000-01-01T${horaCierre}`);
    
    // La duración de cada franja en milisegundos (90 minutos = 5400000 ms)
    const duracionFranja = 90 * 60 * 1000;
    
    // Generar franjas fijas de 90 minutos
    while (horaActual.getTime() + duracionFranja <= horaFin.getTime()) {
      const inicio = horaActual.toISOString().substr(11, 5);
      
      // Avanzar 90 minutos para el fin de esta franja
      const finDate = new Date(horaActual.getTime() + duracionFranja);
      const fin = finDate.toISOString().substr(11, 5);
      
      franjas.push({
        inicio,
        fin,
        seleccionada: false
      });
      
      // La siguiente franja empieza donde termina esta
      horaActual = finDate;
    }
    
    return franjas;
  };
  
  // Función para filtrar franjas ocupadas por reservas existentes
  const filtrarFranjasOcupadas = (franjas: FranjaHoraria[], reservas: any[]): FranjaHoraria[] => {
    if (!reservas || reservas.length === 0) return franjas;
    
    return franjas.filter(franja => {
      // Verificar si esta franja se solapa con alguna reserva existente
      const horaInicioFranja = new Date(`2000-01-01T${franja.inicio}`);
      const horaFinFranja = new Date(`2000-01-01T${franja.fin}`);
      
      for (const reserva of reservas) {
        if (reserva.estado === 'cancelada') continue; // Ignorar reservas canceladas
        
        const horaInicioReserva = new Date(`2000-01-01T${reserva.hora_inicio}`);
        const horaFinReserva = new Date(`2000-01-01T${reserva.hora_fin}`);
        
        // Comprobar si hay solapamiento
        if (
          (horaInicioFranja < horaFinReserva && horaFinFranja > horaInicioReserva) ||
          (horaInicioReserva < horaFinFranja && horaFinReserva > horaInicioFranja)
        ) {
          return false; // Franja ocupada
        }
      }
      
      return true; // Franja disponible
    });
  };
  
  // Función para seleccionar/deseleccionar franjas horarias
  const toggleFranjaHoraria = (franja: FranjaHoraria) => {
    // Copiar el array de franjas disponibles
    const nuevasHorasDisponibles = horasDisponibles.map(f => {
      if (f.inicio === franja.inicio && f.fin === franja.fin) {
        return { ...f, seleccionada: !f.seleccionada };
      }
      return f;
    });
    
    setHorasDisponibles(nuevasHorasDisponibles);
    
    // Actualizar franjas seleccionadas
    const nuevasFranjasSeleccionadas = nuevasHorasDisponibles.filter(f => f.seleccionada);
    setFranjasSeleccionadas(nuevasFranjasSeleccionadas);
  };
  
  // Función para realizar la reserva
  const realizarReserva = async () => {
    if (!user) {
      mostrarMensaje('Debes iniciar sesión para reservar', 'warning');
      return;
    }
    
    if (!pistaDatos || !fechaSeleccionada || franjasSeleccionadas.length === 0) {
      mostrarMensaje('Por favor, completa todos los campos requeridos', 'warning');
      return;
    }
    
    try {
      setCargando(true);
      
      // Crear una reserva para cada franja seleccionada
      for (const franja of franjasSeleccionadas) {
        console.log(`Enviando reserva para franja ${franja.inicio}-${franja.fin}`);
        
        const reservaData = {
          id_usuario: user.id,
          id_pista: pistaSeleccionada,
          fecha: formatearFecha(fechaSeleccionada),
          hora_inicio: formatearHoraAPI(franja.inicio),
          hora_fin: formatearHoraAPI(franja.fin),
          precio_total: pistaDatos.precio_hora, // Usar el precio base de la pista para cada franja
          estado: 'pendiente',
          notas: notas || ''
        };
        
        const respuesta = await apiService.post('/crear-reserva', reservaData);
        console.log("Respuesta de crear reserva:", respuesta);
      }
      
      mostrarMensaje('Reserva realizada con éxito', 'success');
      
      // Limpiar el formulario
      setPistaSeleccionada(null);
      setPistaDatos(null);
      setFechaSeleccionada('');
      setHorasDisponibles([]);
      setFranjasSeleccionadas([]);
      setRangosHorarios([]);
      setNotas('');
      setPrecioTotal(0);
      setTarifaTotal(0);
      
      // Redirigir al home después de un breve retraso
      setTimeout(() => {
        history.push('/home');
      }, 2000);
      
    } catch (error: any) {
      console.error('Error al realizar la reserva:', error);
      mostrarMensaje(`Error al realizar la reserva: ${error.message || 'Error desconocido'}`, 'danger');
    } finally {
      setCargando(false);
    }
  };
  
  // Función para mostrar mensajes
  const mostrarMensaje = (mensaje: string, color: string = 'success') => {
    setMensajeToast(mensaje);
    setColorToast(color);
    setMostrarToast(true);
  };
  
  // Función para formatear fecha
  const formatearFecha = (fecha: string): string => {
    return new Date(fecha).toISOString().split('T')[0];
  };
  
  // Función para formatear fecha para mostrar
  const formatearFechaMostrar = (fecha: string): string => {
    try {
      const fechaObj = new Date(fecha);
      return fechaObj.toLocaleDateString('es-ES', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
      });
    } catch (e) {
      return fecha;
    }
  };
  
  // Función para formatear hora
  const formatearHora = (hora: string): string => {
    return hora.substr(0, 5);
  };
  
  // Función para formatear hora al formato API (HH:MM)
  const formatearHoraAPI = (hora: string): string => {
    return hora.substr(0, 5);
  };

  // Manejar el cambio de fecha
  const handleFechaChange = (e: CustomEvent) => {
    if (e.detail.value) {
      setFechaSeleccionada(e.detail.value as string);
      setIsDateTimeOpen(false);
    }
  };

  // Obtener string de horarios consolidados para mostrar
  const obtenerHorariosConsolidados = (): string => {
    if (rangosHorarios.length === 0) return '';
    
    return rangosHorarios.map(rango => 
      `${formatearHora(rango.inicio)} - ${formatearHora(rango.fin)}`
    ).join(', ');
  };

  // Generar resumen de la reserva
  const generarResumenReserva = () => {
    if (!clubDatos || !pistaDatos || !fechaSeleccionada || franjasSeleccionadas.length === 0) {
      return null;
    }

    const horariosStr = obtenerHorariosConsolidados();

    return (
      <IonCard className="resumen-card">
        <IonCardHeader>
          <IonCardTitle>Resumen de la Reserva</IonCardTitle>
        </IonCardHeader>
        <IonCardContent>
          <IonGrid>
            <IonRow>
              <IonCol size="1">
                <IonIcon icon={businessOutline} color="primary" />
              </IonCol>
              <IonCol size="11">
                <strong>Club:</strong> {clubDatos.nombre}
              </IonCol>
            </IonRow>
            <IonRow>
              <IonCol size="1">
                <IonIcon icon={tennisballOutline} color="primary" />
              </IonCol>
              <IonCol size="11">
                <strong>Pista:</strong> Pista {pistaDatos.numero} - {pistaDatos.tipo}
              </IonCol>
            </IonRow>
            <IonRow>
              <IonCol size="1">
                <IonIcon icon={calendarOutline} color="primary" />
              </IonCol>
              <IonCol size="11">
                <strong>Fecha:</strong> {formatearFechaMostrar(fechaSeleccionada)}
              </IonCol>
            </IonRow>
            <IonRow>
              <IonCol size="1">
                <IonIcon icon={timeOutline} color="primary" />
              </IonCol>
              <IonCol size="11">
                <strong>Horario:</strong> {horariosStr}
              </IonCol>
            </IonRow>
            <IonRow>
              <IonCol size="1">
                <IonIcon icon={cashOutline} color="success" />
              </IonCol>
              <IonCol size="11">
                <strong>Tarifa:</strong> {tarifaTotal}€
              </IonCol>
            </IonRow>
          </IonGrid>
        </IonCardContent>
      </IonCard>
    );
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/home" />
          </IonButtons>
          <IonTitle>Reserva de Pista</IonTitle>
        </IonToolbar>
      </IonHeader>
      <IonContent className="reservas-page">
        <div className="reserva-form-container">
          <form className="reserva-form">
            {/* Selección de Club */}
            <div className="form-group">
              <label>Selecciona un Club *</label>
              <IonSelect 
                value={clubSeleccionado}
                placeholder="Selecciona un club"
                interface="action-sheet"
                onIonChange={e => {
                  setClubSeleccionado(e.detail.value);
                  setPistaSeleccionada(null);
                  setPistaDatos(null);
                  setHorasDisponibles([]);
                  setFranjasSeleccionadas([]);
                  setRangosHorarios([]);
                }}
                className="reserva-select"
              >
                {clubes.map(club => (
                  <IonSelectOption key={club.id} value={club.id}>
                    {club.nombre}
                  </IonSelectOption>
                ))}
              </IonSelect>
            </div>
            
            {/* Selección de Pista */}
            <div className="form-group">
              <label>Selecciona una Pista *</label>
              <IonSelect 
                value={pistaSeleccionada}
                placeholder="Selecciona una pista"
                interface="action-sheet"
                disabled={!clubSeleccionado}
                onIonChange={e => {
                  setPistaSeleccionada(e.detail.value);
                  // Resetear selecciones al cambiar de pista
                  setHorasDisponibles([]);
                  setFranjasSeleccionadas([]);
                  setRangosHorarios([]);
                }}
                className="reserva-select"
              >
                {pistas.map(pista => (
                  <IonSelectOption key={pista.id} value={pista.id}>
                    Pista {pista.numero} - {pista.tipo} - {pista.precio_hora}€/90min
                  </IonSelectOption>
                ))}
              </IonSelect>
            </div>
            
            {/* Selección de Fecha */}
            <div className="form-group" ref={fechaSelectorRef}>
              <label>Selecciona una Fecha *</label>
              <div 
                className="fecha-selector" 
                onClick={() => pistaSeleccionada && setIsDateTimeOpen(true)}
              >
                {fechaSeleccionada ? (
                  <div className="fecha-seleccionada">
                    <IonIcon icon={calendarOutline} />
                    <span>{formatearFechaMostrar(fechaSeleccionada)}</span>
                  </div>
                ) : (
                  <div className="fecha-placeholder">
                    <IonIcon icon={calendarOutline} />
                    <span>Selecciona fecha</span>
                  </div>
                )}
              </div>
              
              <IonPopover
                isOpen={isDateTimeOpen}
                onDidDismiss={() => setIsDateTimeOpen(false)}
                className="date-popover"
                event={undefined}
                arrow={false}
                reference="trigger"
                trigger="fecha-selector"
                side="bottom"
                alignment="start"
              >
                <IonDatetime
                  presentation="date"
                  min={new Date().toISOString()}
                  value={fechaSeleccionada}
                  onIonChange={handleFechaChange}
                ></IonDatetime>
              </IonPopover>
            </div>
            
            {/* Horarios Disponibles */}
            {horasDisponibles.length > 0 && (
              <div className="form-group">
                <label>Selecciona uno o varios Horarios *</label>
                <div className="horarios-grid">
                  {horasDisponibles.map((franja, index) => (
                    <div 
                      key={index}
                      className={`horario-chip ${franja.seleccionada ? 'selected' : ''}`}
                      onClick={() => toggleFranjaHoraria(franja)}
                    >
                      <IonIcon icon={timeOutline} />
                      <span>{formatearHora(franja.inicio)} - {formatearHora(franja.fin)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Notas adicionales */}
            <div className="form-group">
              <label>Notas adicionales</label>
              <IonTextarea
                value={notas}
                placeholder="Escribe aquí cualquier información adicional"
                onIonChange={e => setNotas(e.detail.value || '')}
                className="notas-textarea"
                rows={3}
              ></IonTextarea>
            </div>
            
            {/* Resumen de la reserva */}
            {franjasSeleccionadas.length > 0 && (
              <>
                {generarResumenReserva()}
                
                {/* Precio Total */}
                <div className="precio-total-container">
                  <div className="precio-total">
                    <label>Precio Total:</label>
                    <div className="precio-valor">{precioTotal.toFixed(2)}€</div>
                  </div>
                </div>
              </>
            )}
            
            {/* Botón de reserva */}
            <IonButton 
              expand="block" 
              onClick={realizarReserva}
              disabled={!clubSeleccionado || !pistaSeleccionada || !fechaSeleccionada || franjasSeleccionadas.length === 0}
              className="reservar-button"
            >
              <IonIcon slot="start" icon={tennisballOutline} />
              RESERVAR PISTA
            </IonButton>
          </form>
        </div>
        
        {/* Loading y Toast */}
        <IonLoading isOpen={cargando} message={"Cargando..."} />
        <IonToast
          isOpen={mostrarToast}
          onDidDismiss={() => setMostrarToast(false)}
          message={mensajeToast}
          duration={2000}
          color={colorToast}
        />
      </IonContent>
    </IonPage>
  );
};

export default ReservarPista;
</file>

<file path="src/services/auth.service.ts">
// src/services/auth.service.ts
import { LoginRequest, LoginResponse, RegisterRequest, User, UpdatePasswordRequest } from '../interfaces';
import { API_ENDPOINTS, STORAGE_KEYS } from '../utils/constants';
import apiService from './api.service';

class AuthService {
  async login(credentials: LoginRequest): Promise<LoginResponse> {
    try {
      const response = await apiService.post(API_ENDPOINTS.LOGIN, credentials);
      
      // Guardar información del usuario en localStorage
      localStorage.setItem(STORAGE_KEYS.USER_ID, response.user_id.toString());
      localStorage.setItem(STORAGE_KEYS.USER_ROLE, response.role);
      
      return response;
    } catch (error: any) {
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error('Error al iniciar sesión. Verifica tus credenciales.');
    }
  }
  
  async register(userData: RegisterRequest): Promise<void> {
    try {
      console.log("Enviando solicitud de creación de usuario", userData);
      // Si es registro como club, usamos un flujo diferente
      if (userData.tipo_cuenta === 'club') {
        console.log("Registrando como club:", userData);
        
        // Eliminar tipo_cuenta antes de enviar al backend
        const { tipo_cuenta, club_data, ...userDataToSend } = userData;
        
        // Registrar al usuario administrador primero
        const userResponse = await apiService.post(API_ENDPOINTS.REGISTER, userDataToSend);
        
        console.log("Respuesta de creación de usuario:", userResponse);
        
        // Luego registrar el club asociado al usuario
        if (club_data && userResponse?.user_id) {
          const clubData = {
            nombre: club_data.nombre,
            direccion: club_data.direccion,
            horario_apertura: club_data.horario_apertura,
            horario_cierre: club_data.horario_cierre,
            descripcion: club_data.descripcion || '',
            telefono: club_data.telefono || userData.telefono || '',
            email: club_data.email || userData.email,
            id_administrador: userResponse.user_id
          };
          
          console.log("Creando club con datos:", clubData);
          
          const clubResponse = await apiService.post(API_ENDPOINTS.CLUBS, clubData);
          console.log("Respuesta de creación de club:", clubResponse);
        } else {
          console.error("Falta información del club o ID de usuario:", { 
            clubData: club_data, 
            userId: userResponse?.user_id 
          });
          throw new Error('No se pudo crear el club: faltan datos necesarios');
        }
      } else {
        // Registro normal de usuario
        // Eliminar tipo_cuenta si existe
        const { tipo_cuenta, ...dataToSend } = userData;
        await apiService.post(API_ENDPOINTS.REGISTER, dataToSend);
      }
    } catch (error: any) {
      console.error("Error completo en register:", error);
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error('Error al registrar usuario. Inténtalo de nuevo.');
    }
  }
  
  async logout(userId: number): Promise<void> {
    try {
      await apiService.post(API_ENDPOINTS.LOGOUT, { user_id: userId });
    } catch (error) {
      console.error('Error en logout:', error);
    } finally {
      // Limpiar localStorage incluso si la petición falla
      this.clearSession();
    }
  }
  
  async getCurrentUser(userId: number): Promise<User> {
    try {
      return await apiService.get(`${API_ENDPOINTS.USER}/${userId}`);
    } catch (error: any) {
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error('Error al obtener información del usuario.');
    }
  }

  async updatePassword(data: UpdatePasswordRequest): Promise<void> {
    try {
      await apiService.put(API_ENDPOINTS.UPDATE_PASSWORD, data);
    } catch (error: any) {
      if (error.message) {
        throw new Error(error.message);
      }
      throw new Error('Error al actualizar la contraseña.');
    }
  }
  
  isAuthenticated(): boolean {
    return !!localStorage.getItem(STORAGE_KEYS.USER_ID);
  }
  
  getUserId(): number | null {
    const userId = localStorage.getItem(STORAGE_KEYS.USER_ID);
    return userId ? parseInt(userId, 10) : null;
  }
  
  getUserRole(): string | null {
    return localStorage.getItem(STORAGE_KEYS.USER_ROLE);
  }
  
  clearSession(): void {
    localStorage.removeItem(STORAGE_KEYS.USER_ID);
    localStorage.removeItem(STORAGE_KEYS.USER_ROLE);
    localStorage.removeItem(STORAGE_KEYS.AUTH_TOKEN);
  }
}

export default new AuthService();
</file>

<file path="src/pages/css/Register.css">
/* src/pages/css/Register.css */

.register-container {
  --background: url('/img/fondoLoginRegistro.jpg') no-repeat center center / cover;
}

.register-card {
  margin: 0 auto;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  overflow: hidden;
  margin-top: 20px;
}

.register-card-header {
  background-color: #3880ff;
  color: white;
  padding: 20px;
}

.register-card-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.register-card-content {
  padding: 20px;
  background-color: #1c1c1c;
}

.register-form {
  margin-bottom: 20px;
}

.register-form ion-item {
  --border-radius: 8px;
  --background: #1c1c1c;
  --padding-start: 12px;
  margin-bottom: 25px;
  --border-color: rgba(255, 255, 255, 0.1);
  --highlight-color-focused: #3880ff;
  --min-height: 75px;
}

.register-form ion-input {
  --padding-start: 8px;
  --placeholder-color: #999;
  --padding-top: 30px;
  --padding-bottom: 8px;
  font-size: 16px;
  --color: white;
}

.register-form ion-label {
  font-weight: 500;
  font-size: 16px;
  margin-bottom: 16px;
  --color: #dddddd;
}

.register-form ion-select {
  margin-top: 30px;
  --color: white;
  --placeholder-color: #999;
}

.register-form ion-textarea {
  --color: white;
  --placeholder-color: #999;
}

.register-button {
  margin-top: 20px;
  --border-radius: 8px;
  --background: #3880ff;
  --background-hover: #3171e0;
  font-weight: 600;
  height: 48px;
  text-transform: none;
  font-size: 16px;
}

.register-footer {
  text-align: center;
  margin-top: 30px;
}

.register-footer p {
  color: #dddddd;
  font-size: 15px;
}

.register-footer ion-router-link {
  color: #3880ff;
  font-weight: 500;
  text-decoration: none;
}

.error-message {
  color: #eb445a;
  font-size: 14px;
  margin-bottom: 15px;
  padding: 0 12px;
}

/* Información de campos requeridos */
.required-info {
  font-size: 13px;
  color: #dddddd;
  margin-top: 8px;
  margin-bottom: 30px;
  padding-left: 12px;
}

/* Sección de club */
.club-section {
  margin-top: 20px;
  padding-top: 10px;
  border-top: 1px solid #444;
}

.section-title {
  font-size: 18px;
  font-weight: 600;
  color: #3880ff;
  margin-bottom: 16px;
  padding-left: 12px;
}

/* Animación de carga */
.loading-animation {
  display: flex;
  justify-content: center;
  margin: 20px 0;
}

.register-card {
  margin: 0 auto;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  overflow: hidden;
  margin-top: 20px;
  max-width: 650px;
  width: 90%; 
}

/* Responsive adjustments */
@media (max-width: 576px) {
  .register-card {
    margin-top: 10px;
  }
  
  .register-card-header h2 {
    font-size: 20px;
  }
}

@media (min-width: 768px) {
  .register-container {
    padding: 30px;
  }
}
</file>

<file path="src/pages/Register.tsx">
// src/pages/Register.tsx
import React, { useState, useEffect, useRef } from 'react';
import { 
  IonContent, 
  IonHeader, 
  IonPage, 
  IonTitle, 
  IonToolbar,
  IonInput,
  IonItem,
  IonLabel,
  IonButton,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardTitle,
  IonText,
  IonLoading,
  IonRouterLink,
  IonGrid,
  IonRow,
  IonCol,
  IonToast,
  IonBackButton,
  IonButtons,
  IonIcon,
  IonSelect,
  IonSelectOption,
  IonTextarea,
  useIonViewWillLeave
} from '@ionic/react';
import { 
  personOutline, 
  mailOutline, 
  lockClosedOutline, 
  phonePortraitOutline,
  businessOutline,
  locationOutline,
  timeOutline,
  calendarOutline,
  reader,
  readerOutline
} from 'ionicons/icons';
import { useHistory } from 'react-router';
import { useAuth } from '../context/AuthContext';
import { API_URL, TIPOS_CUENTA } from '../utils/constants';
import { RegisterRequest } from '../interfaces';
import './css/Register.css';

const Register: React.FC = () => {
  // Estados básicos para todos los usuarios
  const [nombre, setNombre] = useState('');
  const [apellidos, setApellidos] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [telefono, setTelefono] = useState('');
  
  // Estados para el tipo de cuenta y datos del club
  const [tipoUsuario, setTipoUsuario] = useState<string>(TIPOS_CUENTA.USUARIO);
  const [nombreClub, setNombreClub] = useState('');
  const [direccionClub, setDireccionClub] = useState('');
  const [descripcionClub, setDescripcionClub] = useState('');
  const [horarioApertura, setHorarioApertura] = useState('08:00');
  const [horarioCierre, setHorarioCierre] = useState('22:00');
  
  // Estados de UI
  const [formError, setFormError] = useState('');
  const [showLoading, setShowLoading] = useState(false);
  const [showToast, setShowToast] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Referencias
  const formRef = useRef<HTMLFormElement>(null);
  
  const { register } = useAuth();
  const history = useHistory();
  
  // Limpiar el foco antes de abandonar la vista
  useIonViewWillLeave(() => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  });

  // Efecto para procesar el registro después de que los estados se actualicen
  useEffect(() => {
    const performRegistration = async () => {
      if (isSubmitting) return;
      setIsSubmitting(true);
  
      try {
          // Validación de datos
          if (!nombre || !email || !password || !confirmPassword) {
              setIsSubmitting(false);
              return;
          }
  
          if (password !== confirmPassword) {
              setFormError('Las contraseñas no coinciden');
              setIsSubmitting(false);
              return;
          }
  
          // Validaciones específicas para club
          if (tipoUsuario === TIPOS_CUENTA.CLUB) {
              if (!nombreClub || !direccionClub || !horarioApertura || !horarioCierre) {
                  setFormError('Por favor, completa todos los datos del club');
                  setIsSubmitting(false);
                  return;
              }
          }
  
          setShowLoading(true);
          setFormError('');
  
          // Preparar datos de registro
          const registroData: RegisterRequest = {
              nombre,
              apellidos: tipoUsuario === TIPOS_CUENTA.CLUB ? "Club" : apellidos,
              email,
              password,
              id_rol: tipoUsuario === TIPOS_CUENTA.CLUB ? 1 : 4,
              telefono
          };
  
          if (tipoUsuario === TIPOS_CUENTA.CLUB) {
              registroData.club_data = {
                  nombre: nombreClub,
                  direccion: direccionClub,
                  horario_apertura: horarioApertura,
                  horario_cierre: horarioCierre,
                  descripcion: descripcionClub,
                  telefono: telefono,
                  email: email
              };
          }
  
          if (tipoUsuario === TIPOS_CUENTA.CLUB) {
              await register({ ...registroData, tipo_cuenta: tipoUsuario });
          } else {
              await register(registroData);
          }
  
          // Mostrar toast de registro con éxito
          setShowToast(true);
  
          //Limpiar campos
          setNombre('');
          setApellidos('');
          setEmail('');
          setPassword('');
          setConfirmPassword('');
          setTelefono('');
  
          if (tipoUsuario === TIPOS_CUENTA.CLUB) {
              setNombreClub('');
              setDireccionClub('');
              setDescripcionClub('');
              setHorarioApertura('08:00');
              setHorarioCierre('22:00');
          }
  
          setTimeout(() => {
              history.replace('/login');
          }, 2000);
  
      } catch (error: any) {
          console.error('Error en registro:', error);
          setFormError(error.message || 'Error al registrar usuario. Inténtalo de nuevo.');
      } finally {
          setShowLoading(false);
          setIsSubmitting(false);
      }
  };
    
    performRegistration();
  }, [isSubmitting, nombre, apellidos, email, password, confirmPassword, telefono, tipoUsuario, 
      nombreClub, direccionClub, descripcionClub, horarioApertura, horarioCierre, register, history]);
  
  const handleRegister = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Sólo marcamos que estamos enviando y dejamos que el useEffect se encargue
    setIsSubmitting(true);
    
    // Eliminar el foco de cualquier elemento activo
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  };
  
  // Manejador para la tecla Enter en los inputs
  const handleKeyDown = (e: React.KeyboardEvent<HTMLIonInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      
      // Forzar actualización del estado antes de enviar el formulario
      const target = e.currentTarget;
      const name = target.name;
      const value = target.value?.toString() || '';
      
      // Actualizar el estado correspondiente
      switch(name) {
        case 'nombre':
          setNombre(value);
          break;
        case 'apellidos':
          setApellidos(value);
          break;
        case 'email':
          setEmail(value);
          break;
        case 'password':
          setPassword(value);
          break;
        case 'confirmPassword':
          setConfirmPassword(value);
          break;
        case 'telefono':
          setTelefono(value);
          break;
        case 'nombreClub':
          setNombreClub(value);
          break;
        case 'direccionClub':
          setDireccionClub(value);
          break;
        case 'horarioApertura':
          setHorarioApertura(value);
          break;
        case 'horarioCierre':
          setHorarioCierre(value);
          break;
      }
      
      // Usar setTimeout para asegurar que los estados se actualicen
      setTimeout(() => {
        if (formRef.current) {
          formRef.current.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
        }
      }, 0);
    }
  };

  // Manejador para textarea (descripción del club)
  const handleTextareaKeyDown = (e: React.KeyboardEvent<HTMLIonTextareaElement>) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      
      // Actualizar el estado
      setDescripcionClub(e.currentTarget.value?.toString() || '');
      
      // Usar setTimeout para asegurar que los estados se actualicen
      setTimeout(() => {
        if (formRef.current) {
          formRef.current.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
        }
      }, 0);
    }
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/login" />
          </IonButtons>
          <IonTitle>Crear cuenta</IonTitle>
        </IonToolbar>
      </IonHeader>
      <IonContent className="register-container">
        <IonGrid>
          <IonRow className="ion-justify-content-center">
            <IonCol size="12" sizeMd="8" sizeLg="6">
              <IonCard className="register-card">
                <IonCardHeader className="register-card-header">
                  <IonCardTitle className="ion-text-center">
                    <h2>Únete a Play4Padel</h2>
                  </IonCardTitle>
                </IonCardHeader>
                <IonCardContent className="register-card-content">
                  <div className="required-info">
                    * Campos obligatorios
                  </div>
                  
                  <form ref={formRef} className="register-form" onSubmit={handleRegister}>
                    {/* Selector de tipo de cuenta */}
                    <IonItem lines="full">
                      <IonIcon icon={businessOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">Tipo de cuenta *</IonLabel>
                      <IonSelect 
                        value={tipoUsuario} 
                        onIonChange={e => setTipoUsuario(e.detail.value)}
                        placeholder="Seleccione tipo de cuenta"
                      >
                        <IonSelectOption value={TIPOS_CUENTA.USUARIO}>Usuario</IonSelectOption>
                        <IonSelectOption value={TIPOS_CUENTA.CLUB}>Club</IonSelectOption>
                      </IonSelect>
                    </IonItem>
                    
                    {/* Campos comunes para ambos tipos de cuenta */}
                    <IonItem lines="full">
                      <IonIcon icon={personOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">
                        {tipoUsuario === TIPOS_CUENTA.CLUB ? 'Nombre de usuario de club *' : 'Nombre *'}
                      </IonLabel>
                      <IonInput 
                        name="nombre"
                        value={nombre} 
                        onIonChange={e => setNombre(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                        required
                      />
                    </IonItem>
                    
                    {/* Solo mostrar campo de apellidos para usuarios normales */}
                    {tipoUsuario !== TIPOS_CUENTA.CLUB && (
                      <IonItem lines="full">
                        <IonIcon icon={personOutline} slot="start" color="medium"></IonIcon>
                        <IonLabel position="floating">Apellidos *</IonLabel>
                        <IonInput 
                          name="apellidos"
                          value={apellidos} 
                          onIonChange={e => setApellidos(e.detail.value?.toString() || '')} 
                          onKeyDown={handleKeyDown}
                          required
                        />
                      </IonItem>
                    )}
                    
                    <IonItem lines="full">
                      <IonIcon icon={mailOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">
                        {tipoUsuario === TIPOS_CUENTA.CLUB ? 'Correo del club *' : 'Email *'}
                      </IonLabel>
                      <IonInput 
                        name="email"
                        type="email" 
                        value={email} 
                        onIonChange={e => setEmail(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                        required
                      />
                    </IonItem>
                    
                    <IonItem lines="full">
                      <IonIcon icon={phonePortraitOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">
                        {tipoUsuario === TIPOS_CUENTA.CLUB ? 'Teléfono de Contacto' : 'Teléfono'}
                      </IonLabel>
                      <IonInput 
                        name="telefono"
                        type="tel" 
                        value={telefono} 
                        onIonChange={e => setTelefono(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                      />
                    </IonItem>
                    
                    <IonItem lines="full">
                      <IonIcon icon={lockClosedOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">Contraseña *</IonLabel>
                      <IonInput 
                        name="password"
                        type="password" 
                        value={password} 
                        onIonChange={e => setPassword(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                        required
                      />
                    </IonItem>
                    
                    <IonItem lines="full">
                      <IonIcon icon={lockClosedOutline} slot="start" color="medium"></IonIcon>
                      <IonLabel position="floating">Confirmar Contraseña *</IonLabel>
                      <IonInput 
                        name="confirmPassword"
                        type="password" 
                        value={confirmPassword} 
                        onIonChange={e => setConfirmPassword(e.detail.value?.toString() || '')} 
                        onKeyDown={handleKeyDown}
                        required
                      />
                    </IonItem>
                    
                    {/* Campos específicos para club */}
                    {tipoUsuario === TIPOS_CUENTA.CLUB && (
                      <>
                        <div className="club-section">
                          <h4 className="section-title">Información del Club</h4>
                          
                          <IonItem lines="full">
                            <IonIcon icon={businessOutline} slot="start" color="medium"></IonIcon>
                            <IonLabel position="floating">Nombre del Club *</IonLabel>
                            <IonInput 
                              name="nombreClub"
                              value={nombreClub} 
                              onIonChange={e => setNombreClub(e.detail.value?.toString() || '')} 
                              onKeyDown={handleKeyDown}
                              required
                            />
                          </IonItem>
                          
                          <IonItem lines="full">
                            <IonIcon icon={locationOutline} slot="start" color="medium"></IonIcon>
                            <IonLabel position="floating">Dirección *</IonLabel>
                            <IonInput 
                              name="direccionClub"
                              value={direccionClub} 
                              onIonChange={e => setDireccionClub(e.detail.value?.toString() || '')} 
                              onKeyDown={handleKeyDown}
                              required
                            />
                          </IonItem>
                          
                          <IonItem lines="full">
                            <IonIcon icon={readerOutline} slot="start" color="medium"></IonIcon>
                            <IonLabel position="floating">Descripción</IonLabel>
                            <IonTextarea
                              name="descripcionClub"
                              value={descripcionClub}
                              onIonChange={e => setDescripcionClub(e.detail.value?.toString() || '')}
                              onKeyDown={handleTextareaKeyDown}
                              autoGrow={true}
                              rows={3}
                            />
                          </IonItem>
                          
                          <IonItem lines="full">
                            <IonIcon icon={timeOutline} slot="start" color="medium"></IonIcon>
                            <IonLabel position="floating">Horario Apertura *</IonLabel>
                            <IonInput 
                              name="horarioApertura"
                              type="time" 
                              value={horarioApertura} 
                              onIonChange={e => setHorarioApertura(e.detail.value?.toString() || '')} 
                              onKeyDown={handleKeyDown}
                              required
                            />
                          </IonItem>
                          
                          <IonItem lines="full">
                            <IonIcon icon={timeOutline} slot="start" color="medium"></IonIcon>
                            <IonLabel position="floating">Horario Cierre *</IonLabel>
                            <IonInput 
                              name="horarioCierre"
                              type="time" 
                              value={horarioCierre} 
                              onIonChange={e => setHorarioCierre(e.detail.value?.toString() || '')} 
                              onKeyDown={handleKeyDown}
                              required
                            />
                          </IonItem>
                        </div>
                      </>
                    )}
                    
                    {formError && (
                      <div className="error-message">
                        <IonText color="danger">
                          <p>{formError}</p>
                        </IonText>
                      </div>
                    )}
                    
                    <IonButton 
                      expand="block" 
                      type="submit" 
                      className="register-button"
                      disabled={isSubmitting}
                    >
                      {tipoUsuario === TIPOS_CUENTA.CLUB ? 'Registrar Club' : 'Crear Cuenta'}
                    </IonButton>
                  </form>
                  
                  <div className="register-footer">
                    <p>
                      ¿Ya tienes cuenta? 
                      <IonRouterLink href="/login" className="ion-padding-start">
                        Inicia sesión
                      </IonRouterLink>
                    </p>
                  </div>
                </IonCardContent>
              </IonCard>
            </IonCol>
          </IonRow>
        </IonGrid>
        
        <IonLoading
          isOpen={showLoading}
          message={tipoUsuario === TIPOS_CUENTA.CLUB ? 'Registrando club...' : 'Registrando usuario...'}
          spinner="circles"
        />
        
        <IonToast
          isOpen={showToast}
          onDidDismiss={() => setShowToast(false)}
          message={tipoUsuario === TIPOS_CUENTA.CLUB 
            ? "Club registrado correctamente. Redirigiendo al login..." 
            : "Usuario registrado correctamente. Redirigiendo al login..."}
          duration={2000}
          position="bottom"
          color="success"
        />
      </IonContent>
    </IonPage>
  );
};

export default Register;
</file>

<file path="src/App.tsx">
// src/App.tsx
import { Redirect, Route } from 'react-router-dom';
import { IonApp, IonRouterOutlet, setupIonicReact, useIonRouter } from '@ionic/react';
import { IonReactRouter } from '@ionic/react-router';
import Home from './pages/Home';
import Login from './pages/Login';
import Register from './pages/Register';
import Profile from './pages/Profile';
import Reservas from './pages/Reservas';
import ManageCourts from './pages/ManageCourts';
import ManageUsers from './pages/ManageUsers';
import CalendarView from './pages/CalendarView';
import MarcadorControl from './pages/MarcadorControl';
import MarcadorPantalla from './pages/MarcadorPantalla';
import { AuthProvider, useAuth } from './context/AuthContext';
import { useEffect } from 'react';

/* Core CSS required for Ionic components to work properly */
import '@ionic/react/css/core.css';

/* Basic CSS for apps built with Ionic */
import '@ionic/react/css/normalize.css';
import '@ionic/react/css/structure.css';
import '@ionic/react/css/typography.css';

/* Optional CSS utils that can be commented out */
import '@ionic/react/css/padding.css';
import '@ionic/react/css/float-elements.css';
import '@ionic/react/css/text-alignment.css';
import '@ionic/react/css/text-transformation.css';
import '@ionic/react/css/flex-utils.css';
import '@ionic/react/css/display.css';

/* Theme variables */
import './theme/variables.css';

setupIonicReact();

// Componente envoltorio para rutas autenticadas
const PrivateRoute: React.FC<{
  component: React.ComponentType<any>;
  path: string;
  exact?: boolean;
}> = ({ component: Component, ...rest }) => {
  const { isAuthenticated, isLoading } = useAuth();
  
  return (
    <Route
      {...rest}
      render={(props) => {
        if (isLoading) {
          return <div>Cargando...</div>;
        }
        
        return isAuthenticated ? (
          <Component {...props} />
        ) : (
          <Redirect to="/login" />
        );
      }}
    />
  );
};

// Componente para rutas que requieren rol específico
const RoleRoute: React.FC<{
  component: React.ComponentType<any>;
  path: string;
  roles: number[];
  exact?: boolean;
}> = ({ component: Component, roles, ...rest }) => {
  const { user, isAuthenticated, isLoading } = useAuth();
  
  return (
    <Route
      {...rest}
      render={(props) => {
        if (isLoading) {
          return <div>Cargando...</div>;
        }
        
        if (!isAuthenticated) {
          return <Redirect to="/login" />;
        }
        
        // Verificar si el usuario tiene uno de los roles permitidos
        if (user && roles.includes(user.id_rol)) {
          return <Component {...props} />;
        }
        
        // Redirigir al home si no tiene el rol adecuado
        return <Redirect to="/home" />;
      }}
    />
  );
};

// Componente para manejar la limpieza de foco en cambios de ruta
const FocusManager: React.FC = () => {
  const ionRouter = useIonRouter();

  useEffect(() => {
    const handleRouteChange = () => {
      // Pequeño delay para asegurar que el cambio de página haya ocurrido
      setTimeout(() => {
        if (document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
        }
      }, 100);
    };

    // Limpiar el foco en el montaje inicial
    handleRouteChange();

    // Suscribirse a cambios de ruta
    document.addEventListener('ionRouterOutletActivated', handleRouteChange);
    
    return () => {
      document.removeEventListener('ionRouterOutletActivated', handleRouteChange);
    };
  }, [ionRouter]);

  return null;
};

const AppContent: React.FC = () => {
  const { isAuthenticated } = useAuth();

  return (
    <IonApp>
      <IonReactRouter>
        {/* Componente para manejar el foco */}
        <FocusManager />
        
        <IonRouterOutlet>
          {/* Rutas públicas */}
          <Route path="/login" exact>
            {isAuthenticated ? <Redirect to="/home" /> : <Login />}
          </Route>
          
          <Route path="/register" exact>
            {isAuthenticated ? <Redirect to="/home" /> : <Register />}
          </Route>
          
          {/* Rutas privadas - para todos los usuarios autenticados */}
          <PrivateRoute path="/home" exact component={Home} />
          <PrivateRoute path="/profile" exact component={Profile} />
          <PrivateRoute path="/reservas" exact component={Reservas} />
          <PrivateRoute path="/calendar" exact component={CalendarView} />
          
          {/* Rutas que requieren rol específico - solo administradores (id_rol = 1) */}
          <RoleRoute 
            path="/manage-courts" 
            exact 
            component={ManageCourts} 
            roles={[1]} 
          />
          
          <RoleRoute 
            path="/manage-users" 
            exact 
            component={ManageUsers} 
            roles={[1]} 
          />
          
          {/* Rutas para el marcador */}
          <PrivateRoute path="/marcador-control" exact component={MarcadorControl} />
          <PrivateRoute path="/marcador-pantalla" exact component={MarcadorPantalla} />
          
          {/* Rutas de compatibilidad para el marcador */}
          <PrivateRoute path="/marcador" exact component={MarcadorControl} />
          <PrivateRoute path="/club/marcador-control" exact component={MarcadorControl} />
          <PrivateRoute path="/club/marcador" exact component={MarcadorPantalla} />

          {/* Redirección por defecto */}
          <Route exact path="/">
            {isAuthenticated ? <Redirect to="/home" /> : <Redirect to="/login" />}
          </Route>
        </IonRouterOutlet>
      </IonReactRouter>
    </IonApp>
  );
};

const App: React.FC = () => (
  <AuthProvider>
    <AppContent />
  </AuthProvider>
);

export default App;
</file>

<file path="src/pages/CalendarView.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { 
  IonContent, 
  IonHeader, 
  IonPage, 
  IonTitle, 
  IonToolbar,
  IonButtons,
  IonBackButton,
  IonGrid,
  IonRow,
  IonCol,
  IonCard,
  IonCardHeader,
  IonCardTitle,
  IonCardContent,
  IonItem,
  IonLabel,
  IonList,
  IonIcon,
  IonLoading,
  IonToast,
  IonChip,
  IonButton,
  IonModal,
  IonSegment,
  IonSegmentButton,
  IonText,
  IonItemDivider,
  IonSpinner,
  IonRefresher,
  IonRefresherContent,
  IonAlert
} from '@ionic/react';
import { 
  calendarOutline, 
  timeOutline, 
  personOutline, 
  cashOutline, 
  tennisballOutline,
  closeCircleOutline,
  chevronBackOutline,
  chevronForwardOutline,
  refreshOutline
} from 'ionicons/icons';
import { useAuth } from '../context/AuthContext';
import apiService from '../services/api.service';
import './css/CalendarView.css';

interface ReservaDetalle {
  id: number;
  id_usuario: number;
  id_pista: number;
  nombre_usuario: string;
  fecha: string;
  hora_inicio: string;
  hora_fin: string;
  precio_total: number;
  estado: string;
  pista_numero?: number;
  pista_tipo?: string;
}

interface DiaCalendario {
  fecha: Date;
  diaMes: number;
  enMesActual: boolean;
  tieneReservas: boolean;
  numReservas: number;
}

interface ReservasPorDia {
  fecha: string;
  fechaFormateada: string;
  reservas: ReservaDetalle[];
}

const CalendarView: React.FC = () => {
  const { user } = useAuth();
  const [fechaActual, setFechaActual] = useState<Date>(new Date());
  const [diasCalendario, setDiasCalendario] = useState<DiaCalendario[]>([]);
  const [diaSeleccionado, setDiaSeleccionado] = useState<Date | null>(null);
  const [reservasDelDia, setReservasDelDia] = useState<ReservaDetalle[]>([]);
  const [reservasDelMes, setReservasDelMes] = useState<ReservasPorDia[]>([]);
  const [cargando, setCargando] = useState<boolean>(false);
  const [cargandoLista, setCargandoLista] = useState<boolean>(false);
  const [mostrarToast, setMostrarToast] = useState<boolean>(false);
  const [mensajeToast, setMensajeToast] = useState<string>('');
  const [colorToast, setColorToast] = useState<string>('success');
  const [mostrarDetalleReserva, setMostrarDetalleReserva] = useState<boolean>(false);
  const [reservaSeleccionada, setReservaSeleccionada] = useState<ReservaDetalle | null>(null);
  const [vistaActual, setVistaActual] = useState<'calendario' | 'lista'>('calendario');
  const [fechasConReservas, setFechasConReservas] = useState<{[key: string]: number}>({});
  const [mensajeError, setMensajeError] = useState<string>('');
  const [showCancelConfirm, setShowCancelConfirm] = useState<boolean>(false);
  const [reservaToCancel, setReservaToCancel] = useState<number | null>(null);
  
  const contentRef = useRef<HTMLIonContentElement>(null);

  // Cargar datos iniciales
  useEffect(() => {
    if (user) {
      generarDiasCalendario(fechaActual);
      cargarReservasMes(fechaActual);
      
      // Establecer el día actual como seleccionado por defecto
      const hoy = new Date();
      setDiaSeleccionado(hoy);
      cargarReservasDia(hoy);
    }
  }, [user]);
  
  // Efecto adicional para cuando cambia el mes
  useEffect(() => {
    if (user) {
      generarDiasCalendario(fechaActual);
      cargarReservasMes(fechaActual);
    }
  }, [fechaActual]);

  // Efecto para manejar cambios de vista
  useEffect(() => {
    if (vistaActual === 'lista' && user && reservasDelMes.length === 0) {
      // Forzar la carga de los datos para la vista de lista
      cargarReservasMes(fechaActual, true);
    }
    
    // Hacer scroll al inicio cuando cambia la vista
    if (contentRef.current) {
      contentRef.current.scrollToTop(300);
    }
  }, [vistaActual]);

  // Efecto para actualizar días con reservas
  useEffect(() => {
    // Solo actualizar si hay dias en el calendario
    if (diasCalendario.length > 0) {
      const nuevosDias = diasCalendario.map(dia => {
        const fechaStr = formatearFecha(dia.fecha);
        return {
          ...dia,
          tieneReservas: !!fechasConReservas[fechaStr],
          numReservas: fechasConReservas[fechaStr] || 0
        };
      });
      
      setDiasCalendario(nuevosDias);
    }
  }, [fechasConReservas]);

  // Generar días para el calendario
  const generarDiasCalendario = (fecha: Date) => {
    const primerDiaMes = new Date(fecha.getFullYear(), fecha.getMonth(), 1);
    const ultimoDiaMes = new Date(fecha.getFullYear(), fecha.getMonth() + 1, 0);
    
    const diasArray: DiaCalendario[] = [];
    
    // Calcular primer día de la semana (ajustado para empezar en lunes)
    let primerDiaMostrado = new Date(primerDiaMes);
    const diaSemana = primerDiaMes.getDay();
    primerDiaMostrado.setDate(primerDiaMostrado.getDate() - (diaSemana === 0 ? 6 : diaSemana - 1));
    
    // Generar 42 días (6 semanas) para cubrir todo el mes
    for (let i = 0; i < 42; i++) {
      const fechaDia = new Date(primerDiaMostrado);
      fechaDia.setDate(primerDiaMostrado.getDate() + i);
      
      diasArray.push({
        fecha: fechaDia,
        diaMes: fechaDia.getDate(),
        enMesActual: fechaDia.getMonth() === fecha.getMonth(),
        tieneReservas: false,
        numReservas: 0
      });
    }
    
    setDiasCalendario(diasArray);
  };

  // Handler para pull-to-refresh
  const handleRefresh = (event: CustomEvent) => {
    setTimeout(() => {
      actualizarReservas();
      event.detail.complete();
    }, 1000);
  };

  // Cargar reservas del mes actual
  const cargarReservasMes = async (fecha: Date, forceReload: boolean = false) => {
    if (!user) return;
    
    // Obtener ID del club
    let idClub = user.id_club;
    if (!idClub) {
      try {
        const clubsResponse = await apiService.get(`/clubs?id_administrador=${user.id}`);
        if (Array.isArray(clubsResponse) && clubsResponse.length > 0) {
          idClub = clubsResponse[0].id;
        } else {
          mostrarMensaje('No se encontró un club asignado a tu cuenta', 'warning');
          return;
        }
      } catch (error) {
        console.error('Error al buscar clubes del administrador:', error);
        mostrarMensaje('Error al obtener información del club', 'danger');
        return;
      }
    }
    
    try {
      // Si estamos en la vista de lista, mostrar el spinner específico
      if (vistaActual === 'lista') {
        setCargandoLista(true);
      } else {
        setCargando(true);
      }
      
      setMensajeError('');
      
      // Obtener primer y último día del mes
      const primerDiaMes = new Date(fecha.getFullYear(), fecha.getMonth(), 1);
      const ultimoDiaMes = new Date(fecha.getFullYear(), fecha.getMonth() + 1, 0);
      
      // Formatear fechas para la API
      const fechaInicio = formatearFecha(primerDiaMes);
      const fechaFin = formatearFecha(ultimoDiaMes);
      
      // Obtener todas las reservas del club
      const response = await apiService.get(`/reservas?id_club=${idClub}`);
      
      if (Array.isArray(response)) {
        // Contar reservas por fecha (para el calendario)
        const reservasPorFecha: {[key: string]: number} = {};
        
        // Para la vista de lista, agrupar reservas por día
        const reservasPorDia: {[key: string]: any[]} = {};
        
        // Filtrar solo las reservas del mes actual
        response.forEach(reserva => {
          const fechaReserva = reserva.fecha;
          try {
            // Convertir la fecha de string a Date para comparación
            const fechaObj = new Date(fechaReserva);
            // Verificar si está en el mes actual
            if (fechaObj.getMonth() === fecha.getMonth() && 
                fechaObj.getFullYear() === fecha.getFullYear()) {
              
              // Para el calendario
              if (reservasPorFecha[fechaReserva]) {
                reservasPorFecha[fechaReserva]++;
              } else {
                reservasPorFecha[fechaReserva] = 1;
              }
              
              // Para la vista de lista
              if (!reservasPorDia[fechaReserva]) {
                reservasPorDia[fechaReserva] = [];
              }
              reservasPorDia[fechaReserva].push(reserva);
            }
          } catch (err) {
            console.error(`Error procesando fecha de reserva: ${fechaReserva}`, err);
          }
        });
        
        setFechasConReservas(reservasPorFecha);
        
        // Si no hay reservas para el mes, simplemente establecer array vacío
        if (Object.keys(reservasPorDia).length === 0) {
          setReservasDelMes([]);
          return;
        }
        
        // Procesar cada día para obtener detalles adicionales de reservas
        const procesarReservasPorDia = async () => {
          const reservasPorDiaArray: ReservasPorDia[] = [];
          
          // Obtener las fechas ordenadas
          const fechasOrdenadas = Object.keys(reservasPorDia).sort();
          
          for (const fecha of fechasOrdenadas) {
            const reservasDelDia = reservasPorDia[fecha];
            
            // Procesar cada reserva para añadir detalles
            const reservasDetalladas = await Promise.all(
              reservasDelDia.map(async (reserva) => {
                let nombreUsuario = "Usuario";
                let pistaNumero = null;
                let pistaTipo = null;
                
                try {
                  // Obtener datos del usuario
                  const usuarioResponse = await apiService.get(`/user/${reserva.id_usuario}`);
                  
                  if (usuarioResponse && usuarioResponse.nombre) {
                    nombreUsuario = `${usuarioResponse.nombre} ${usuarioResponse.apellidos || ''}`;
                  }
                  
                  // Obtener datos de la pista
                  const pistaResponse = await apiService.get(`/pistas/${reserva.id_pista}`);
                  
                  if (pistaResponse && pistaResponse.numero) {
                    pistaNumero = pistaResponse.numero;
                    pistaTipo = pistaResponse.tipo;
                  }
                } catch (error) {
                  console.error('Error al obtener detalles para la reserva:', error);
                }
                
                return {
                  ...reserva,
                  nombre_usuario: nombreUsuario,
                  pista_numero: pistaNumero,
                  pista_tipo: pistaTipo
                };
              })
            );
            
            // Ordenar las reservas por hora
            reservasDetalladas.sort((a, b) => {
              if (a.hora_inicio < b.hora_inicio) return -1;
              if (a.hora_inicio > b.hora_inicio) return 1;
              return 0;
            });
            
            // Construir la fecha formateada
            let fechaFormateada = '';
            try {
              const fechaObj = new Date(fecha);
              fechaFormateada = fechaObj.toLocaleDateString('es-ES', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
              });
            } catch (err) {
              console.error(`Error formateando fecha: ${fecha}`, err);
              fechaFormateada = fecha; // Usar la fecha sin formatear en caso de error
            }
            
            // Añadir al array de días con sus reservas
            reservasPorDiaArray.push({
              fecha,
              fechaFormateada: fechaFormateada,
              reservas: reservasDetalladas
            });
          }
          
          return reservasPorDiaArray;
        };
        
        // Procesar y establecer las reservas por día
        const reservasPorDiaArray = await procesarReservasPorDia();
        
        if (reservasPorDiaArray.length > 0) {
          setReservasDelMes(reservasPorDiaArray);
        } else {
          setMensajeError('No se pudieron procesar las reservas del mes');
        }
      } else {
        setReservasDelMes([]);
        setMensajeError('La respuesta del servidor no tiene el formato esperado');
      }
    } catch (error) {
      console.error('Error al cargar reservas del mes:', error);
      mostrarMensaje('Error al cargar reservas del mes', 'danger');
      setReservasDelMes([]);
      setMensajeError('Error de conexión al cargar reservas');
    } finally {
      setCargando(false);
      setCargandoLista(false);
    }
  };

  // Cargar reservas de un día específico
  const cargarReservasDia = async (fecha: Date) => {
    if (!user) return;
    
    // Obtener el ID del club manualmente si no está en el objeto user
    let idClub = user.id_club;
    
    if (!idClub) {
      try {
        // Buscar los clubes asociados al administrador
        const clubsResponse = await apiService.get(`/clubs?id_administrador=${user.id}`);
        
        if (Array.isArray(clubsResponse) && clubsResponse.length > 0) {
          idClub = clubsResponse[0].id;
        } else {
          mostrarMensaje('No se encontró un club asignado a tu cuenta', 'warning');
          return;
        }
      } catch (error) {
        console.error('Error al buscar clubes del administrador:', error);
        mostrarMensaje('Error al obtener información del club', 'danger');
        return;
      }
    }
    
    try {
      setCargando(true);
      
      // Formatear la fecha manteniendo la zona horaria local
      const year = fecha.getFullYear();
      const month = String(fecha.getMonth() + 1).padStart(2, '0');
      const day = String(fecha.getDate()).padStart(2, '0');
      const fechaFormateada = `${year}-${month}-${day}`;
      
      // URL para obtener las reservas
      const url = `/reservas?id_club=${idClub}&fecha=${fechaFormateada}`;
      
      // Realizar la solicitud a la API
      const response = await apiService.get(url);
      
      // Verificar si la respuesta es un array
      if (!Array.isArray(response)) {
        setReservasDelDia([]);
        setCargando(false);
        return;
      }
      
      // Si no hay reservas, actualizar el estado y salir
      if (response.length === 0) {
        setReservasDelDia([]);
        setCargando(false);
        return;
      }
      
      // Procesar cada reserva para añadir detalles
      const reservasPromesas = response.map(async (reserva) => {
        // Inicializar valores por defecto
        let nombreUsuario = "Usuario";
        let pistaNumero = null;
        let pistaTipo = null;
        
        try {
          // Obtener datos del usuario
          const usuarioResponse = await apiService.get(`/user/${reserva.id_usuario}`);
          
          if (usuarioResponse && usuarioResponse.nombre) {
            nombreUsuario = `${usuarioResponse.nombre} ${usuarioResponse.apellidos || ''}`;
          }
          
          // Obtener datos de la pista
          const pistaResponse = await apiService.get(`/pistas/${reserva.id_pista}`);
          
          if (pistaResponse && pistaResponse.numero) {
            pistaNumero = pistaResponse.numero;
            pistaTipo = pistaResponse.tipo;
          }
        } catch (error) {
          console.error(`Error al obtener detalles para la reserva:`, error);
        }
        
        // Crear objeto con detalles completos
        return {
          ...reserva,
          nombre_usuario: nombreUsuario,
          pista_numero: pistaNumero,
          pista_tipo: pistaTipo
        };
      });
      
      // Esperar a que todas las promesas se resuelvan
      const reservasDetalladas = await Promise.all(reservasPromesas);
      
      // Ordenar por hora de inicio
      reservasDetalladas.sort((a, b) => {
        if (a.hora_inicio < b.hora_inicio) return -1;
        if (a.hora_inicio > b.hora_inicio) return 1;
        return 0;
      });
      
      // Actualizar el estado con las reservas procesadas
      setReservasDelDia(reservasDetalladas);
      
    } catch (error) {
      console.error('Error al cargar reservas del día:', error);
      mostrarMensaje('Error al cargar reservas del día', 'danger');
      setReservasDelDia([]);
    } finally {
      setCargando(false);
    }
  };

  // Manejar clic en día del calendario
  const handleClickDia = (dia: DiaCalendario) => {
    // Establecer el día seleccionado primero
    setDiaSeleccionado(dia.fecha);
    
    // Luego cargar las reservas para ese día
    cargarReservasDia(dia.fecha);
  };

  // Manejar clic en reserva para ver detalles
  const handleClickReserva = (reserva: ReservaDetalle) => {
    setReservaSeleccionada(reserva);
    setMostrarDetalleReserva(true);
  };

  // Navegar al mes anterior
  const irMesAnterior = () => {
    const nuevaFecha = new Date(fechaActual);
    nuevaFecha.setMonth(nuevaFecha.getMonth() - 1);
    setFechaActual(nuevaFecha);
  };

  // Navegar al mes siguiente
  const irMesSiguiente = () => {
    const nuevaFecha = new Date(fechaActual);
    nuevaFecha.setMonth(nuevaFecha.getMonth() + 1);
    setFechaActual(nuevaFecha);
  };

  // Navegar a hoy
  const irAHoy = () => {
    const hoy = new Date();
    setFechaActual(hoy);
    setDiaSeleccionado(hoy);
    cargarReservasDia(hoy);
  };

  // Cambiar vista (calendario o lista)
  const cambiarVista = (nuevaVista: 'calendario' | 'lista') => {
    setVistaActual(nuevaVista);
    
    // Si cambiamos a lista y no hay datos, intentar cargar
    if (nuevaVista === 'lista' && reservasDelMes.length === 0) {
      cargarReservasMes(fechaActual, true);
    }
  };

  // Actualizar reservas (refrescar datos)
  const actualizarReservas = () => {
    if (vistaActual === 'calendario') {
      cargarReservasMes(fechaActual);
      if (diaSeleccionado) {
        cargarReservasDia(diaSeleccionado);
      }
    } else {
      cargarReservasMes(fechaActual, true);
    }
  };

  // Cancelar reserva
  const cancelarReserva = (reservaId: number) => {
    setReservaToCancel(reservaId);
    setShowCancelConfirm(true);
  };
  
  // Agregar una nueva función para ejecutar la cancelación después de la confirmación
  const confirmCancelReserva = async () => {
    if (!reservaToCancel) return;
    
    try {
      setCargando(true);
      
      const response = await apiService.delete(`/eliminar-reserva/${reservaToCancel}`);
      
      if (response && response.message) {
        mostrarMensaje(response.message, 'success');
      } else {
        mostrarMensaje('Reserva cancelada correctamente', 'success');
      }
      
      if (diaSeleccionado) {
        cargarReservasDia(diaSeleccionado);
      }
      cargarReservasMes(fechaActual);
      
      setMostrarDetalleReserva(false);
      
    } catch (error: any) {
      console.error('Error al cancelar reserva:', error);
      
      const errorMessage = error.message || 'Error al cancelar la reserva';
      mostrarMensaje(errorMessage, 'danger');
    } finally {
      setCargando(false);
      setShowCancelConfirm(false);
      setReservaToCancel(null);
    }
  };

  const mostrarMensaje = (mensaje: string, color: string = 'success') => {
    setMensajeToast(mensaje);
    setColorToast(color);
    setMostrarToast(true);
  };

  const formatearFecha = (fecha: Date): string => {
    if (!fecha) return '';
    
    const year = fecha.getFullYear();
    const month = String(fecha.getMonth() + 1).padStart(2, '0');
    const day = String(fecha.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const formatearFechaMostrar = (fecha: Date): string => {
    return fecha.toLocaleDateString('es-ES', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const formatearMesAnio = (fecha: Date): string => {
    return fecha.toLocaleDateString('es-ES', {
      month: 'long',
      year: 'numeric'
    });
  };

  const formatearHora = (hora: string): string => {
    return hora.substring(0, 5);
  };


  const getColorEstadoReserva = (estado: string): string => {
    switch (estado.toLowerCase()) {
      case 'pendiente':
        return 'warning';
      case 'confirmada':
        return 'success';
      case 'cancelada':
        return 'danger';
      case 'completada':
        return 'primary';
      default:
        return 'medium';
    }
  };

  // Generar cabecera de días de la semana
  const renderDiasSemana = () => {
    const dias = ['Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb', 'Dom'];
    
    return (
      <IonRow className="dias-semana">
        {dias.map((dia, index) => (
          <IonCol key={index}>{dia}</IonCol>
        ))}
      </IonRow>
    );
  };

  // Generar grid del calendario
  const renderCalendario = () => {
    const semanas: DiaCalendario[][] = [];
    for (let i = 0; i < diasCalendario.length; i += 7) {
      semanas.push(diasCalendario.slice(i, i + 7));
    }


    const cambiarEstadoReserva = async (reservaId: number, estadoActual: string) => {
      try {
        setCargando(true);
        
        // Determinar el nuevo estado (alternar entre "pendiente" y "reservado")
        const nuevoEstado = estadoActual === 'pendiente' ? 'reservado' : 'pendiente';
        
        // Llamar al endpoint para actualizar el estado
        const response = await apiService.put(`/modificar-reserva/${reservaId}`, {
          estado: nuevoEstado
        });
        
        // Verificar si la respuesta es exitosa
        if (response && response.message) {
          mostrarMensaje(response.message, 'success');
        } else {
          mostrarMensaje(`Estado cambiado a: ${nuevoEstado}`, 'success');
        }
        
        // Actualizar la reserva seleccionada con el nuevo estado
        if (reservaSeleccionada) {
          setReservaSeleccionada({
            ...reservaSeleccionada,
            estado: nuevoEstado
          });
        }
        
        // Actualizar datos
        if (diaSeleccionado) {
          cargarReservasDia(diaSeleccionado);
        }
        cargarReservasMes(fechaActual);
        
      } catch (error: any) {
        console.error('Error al cambiar estado de reserva:', error);
        const errorMessage = error.message || 'Error al cambiar el estado de la reserva';
        mostrarMensaje(errorMessage, 'danger');
      } finally {
        setCargando(false);
      }
    };
    
    return (
      <>
        {renderDiasSemana()}
        
        {semanas.map((semana, semanaIndex) => (
          <IonRow key={`semana-${semanaIndex}`} className="semana">
            {semana.map((dia, diaIndex) => (
              <IonCol 
                key={`dia-${semanaIndex}-${diaIndex}`} 
                className={`dia ${!dia.enMesActual ? 'otro-mes' : ''} ${dia.tieneReservas ? 'tiene-reservas' : ''} ${diaSeleccionado && diaSeleccionado.getDate() === dia.diaMes && diaSeleccionado.getMonth() === dia.fecha.getMonth() ? 'seleccionado' : ''}`}
                onClick={() => handleClickDia(dia)}
              >
                <div className="numero-dia">{dia.diaMes}</div>
                {dia.tieneReservas && (
                  <div className="indicador-reservas">{dia.numReservas}</div>
                )}
              </IonCol>
            ))}
          </IonRow>
        ))}
      </>
    );
  };

  // Renderizar lista de reservas del día
  const renderListaReservas = () => {
    if (!diaSeleccionado) {
      return (
        <div className="sin-dia-seleccionado">
          <IonText color="medium">
            <p>Selecciona un día para ver sus reservas</p>
          </IonText>
        </div>
      );
    }
    
    if (reservasDelDia.length === 0) {
      return (
        <div className="sin-reservas">
          <IonText color="medium">
            <p>No hay reservas para el {formatearFechaMostrar(diaSeleccionado)}</p>
          </IonText>
        </div>
      );
    }
    
    return (
      <IonList className="lista-reservas">
        {reservasDelDia.map((reserva) => (
          <IonItem 
            key={reserva.id} 
            button 
            detail 
            onClick={() => handleClickReserva(reserva)}
            className={`reserva-item estado-${reserva.estado.toLowerCase()}`}
          >
            <IonIcon slot="start" icon={tennisballOutline} />
            <IonLabel>
              <h2>{reserva.nombre_usuario}</h2>
              <p>
                <IonIcon icon={timeOutline} /> {formatearHora(reserva.hora_inicio)} - {formatearHora(reserva.hora_fin)}
              </p>
              <p>
                <IonIcon icon={cashOutline} /> {reserva.precio_total.toFixed(2)}€
              </p>
            </IonLabel>
            <IonChip slot="end" color={getColorEstadoReserva(reserva.estado)}>
              {reserva.estado}
            </IonChip>
          </IonItem>
        ))}
      </IonList>
    );
  };

  // Renderizar lista de todas las reservas del mes
  const renderListaReservasMes = () => {
    if (cargandoLista) {
      return (
        <div className="cargando-lista">
          <IonSpinner name="circles" color="light"/>
          <p>Cargando reservas...</p>
        </div>
      );
    }
    
    if (mensajeError) {
      return (
        <div className="error-mensaje">
          <IonText color="danger">
            <p>{mensajeError}</p>
          </IonText>
          <IonButton onClick={() => cargarReservasMes(fechaActual, true)}>
            <IonIcon slot="start" icon={refreshOutline} />
            Reintentar
          </IonButton>
        </div>
      );
    }
    
    if (reservasDelMes.length === 0) {
      return (
        <div className="sin-reservas">
          <IonText color="medium">
            <p>No hay reservas para el mes actual</p>
          </IonText>
          <IonButton size="small" onClick={actualizarReservas} className="refresh-button">
            <IonIcon slot="start" icon={refreshOutline} />
            Actualizar
          </IonButton>
        </div>
      );
    }
    
    return (
      <IonList className="lista-reservas-mes">
        {reservasDelMes.map((dia) => (
          <React.Fragment key={dia.fecha}>
            <IonItemDivider color="primary" sticky className="fecha-divider">
              <IonLabel>
                {dia.fechaFormateada}
              </IonLabel>
              <IonChip slot="end" color="light">{dia.reservas.length} reservas</IonChip>
            </IonItemDivider>
            
            {dia.reservas.map((reserva) => (
              <IonItem 
                key={reserva.id} 
                button 
                detail 
                onClick={() => handleClickReserva(reserva)}
                className={`reserva-item estado-${reserva.estado.toLowerCase()}`}
              >
                <IonIcon slot="start" icon={tennisballOutline} />
                <IonLabel>
                  <h2>{reserva.nombre_usuario}</h2>
                  <p>
                    <IonIcon icon={timeOutline} /> {formatearHora(reserva.hora_inicio)} - {formatearHora(reserva.hora_fin)}
                  </p>
                  <p>
                    <IonIcon icon={cashOutline} /> {reserva.precio_total.toFixed(2)}€
                  </p>
                </IonLabel>
                <IonChip slot="end" color={getColorEstadoReserva(reserva.estado)}>
                  {reserva.estado}
                </IonChip>
              </IonItem>
            ))}
          </React.Fragment>
        ))}
      </IonList>
    );
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar color="primary">
          <IonButtons slot="start">
            <IonBackButton defaultHref="/home" />
          </IonButtons>
          <IonTitle>Reservas y Calendario</IonTitle>
          <IonButtons slot="end">
            <IonButton onClick={actualizarReservas}>
              <IonIcon slot="icon-only" icon={refreshOutline} />
            </IonButton>
          </IonButtons>
        </IonToolbar>
      </IonHeader>
      
      <IonContent className="calendar-view" ref={contentRef}>
        {/* Pull-to-refresh */}
        <IonRefresher slot="fixed" onIonRefresh={handleRefresh}>
          <IonRefresherContent></IonRefresherContent>
        </IonRefresher>
        
        {/* Segmento para cambiar entre vista calendario y lista */}
        <IonSegment value={vistaActual} onIonChange={e => cambiarVista(e.detail.value as 'calendario' | 'lista')}>
          <IonSegmentButton value="calendario">
            <IonLabel>CALENDARIO</IonLabel>
          </IonSegmentButton>
          <IonSegmentButton value="lista">
            <IonLabel>LISTA</IonLabel>
          </IonSegmentButton>
        </IonSegment>
        
        {vistaActual === 'calendario' && (
          <div className="vista-calendario">
            {/* Navegación del calendario */}
            <div className="navegacion-calendario">
              <IonButton fill="clear" onClick={irMesAnterior}>
                <IonIcon slot="icon-only" icon={chevronBackOutline} />
              </IonButton>
              
              <h2 className="titulo-mes">{formatearMesAnio(fechaActual)}</h2>
              
              <IonButton fill="clear" onClick={irMesSiguiente}>
                <IonIcon slot="icon-only" icon={chevronForwardOutline} />
              </IonButton>
              
              <IonButton size="small" fill="solid" onClick={irAHoy} className="boton-hoy">
                Hoy
              </IonButton>
            </div>
            
            {/* Grid del calendario */}
            <IonGrid className="grid-calendario">
              {renderCalendario()}
            </IonGrid>
            
            {/* Panel de reservas del día seleccionado */}
            <div className="panel-reservas">
              {diaSeleccionado && (
                <h3 className="fecha-seleccionada">
                  {formatearFechaMostrar(diaSeleccionado)}
                </h3>
              )}
              
              {renderListaReservas()}
            </div>
          </div>
        )}
        
        {/* Vista de lista completa del mes */}
        {vistaActual === 'lista' && (
          <div className="panel-reservas pantalla-completa">
            {renderListaReservasMes()}
          </div>
        )}
        
        {/* Modal de detalle de reserva */}
        <IonModal isOpen={mostrarDetalleReserva} onDidDismiss={() => setMostrarDetalleReserva(false)}>
          <IonHeader>
            <IonToolbar>
              <IonButtons slot="end">
                <IonButton onClick={() => setMostrarDetalleReserva(false)}>
                  Cerrar
                </IonButton>
              </IonButtons>
              <IonTitle>Detalle de Reserva</IonTitle>
            </IonToolbar>
          </IonHeader>
          
          <IonContent>
            {reservaSeleccionada && (
              <IonCard>
                <IonCardHeader>
                  <IonCardTitle>Reserva #{reservaSeleccionada.id}</IonCardTitle>
                </IonCardHeader>
                
                <IonCardContent>
                  <IonGrid>
                    <IonRow>
                      <IonCol size="12">
                        <IonItem lines="none">
                          <IonIcon icon={personOutline} slot="start" color="primary" />
                          <IonLabel>
                            <h2>Cliente</h2>
                            <p>{reservaSeleccionada.nombre_usuario}</p>
                          </IonLabel>
                        </IonItem>
                      </IonCol>
                      
                      <IonCol size="12">
                        <IonItem lines="none">
                          <IonIcon icon={calendarOutline} slot="start" color="primary" />
                          <IonLabel>
                            <h2>Fecha</h2>
                            <p>{new Date(reservaSeleccionada.fecha).toLocaleDateString('es-ES')}</p>
                          </IonLabel>
                        </IonItem>
                      </IonCol>
                      
                      <IonCol size="12">
                        <IonItem lines="none">
                          <IonIcon icon={timeOutline} slot="start" color="primary" />
                          <IonLabel>
                            <h2>Horario</h2>
                            <p>{formatearHora(reservaSeleccionada.hora_inicio)} - {formatearHora(reservaSeleccionada.hora_fin)}</p>
                          </IonLabel>
                        </IonItem>
                      </IonCol>
                      
                      <IonCol size="12">
                        <IonItem lines="none">
                          <IonIcon icon={tennisballOutline} slot="start" color="success" />
                          <IonLabel>
                            <h2>Pista</h2>
                            <p>
                              {reservaSeleccionada.pista_numero 
                                ? `Pista ${reservaSeleccionada.pista_numero} - ${reservaSeleccionada.pista_tipo}` 
                                : `ID: ${reservaSeleccionada.id_pista}`}
                            </p>
                          </IonLabel>
                        </IonItem>
                      </IonCol>
                      
                      <IonCol size="12">
                        <IonItem lines="none">
                          <IonIcon icon={cashOutline} slot="start" color="success" />
                          <IonLabel>
                            <h2>Precio</h2>
                            <p>{reservaSeleccionada.precio_total.toFixed(2)}€</p>
                          </IonLabel>
                        </IonItem>
                      </IonCol>
                      
                      <IonCol size="12">
                        <IonItem lines="none">
                          <IonLabel>
                            <h2>Estado</h2>
                          </IonLabel>
                          <IonChip color={getColorEstadoReserva(reservaSeleccionada.estado)} slot="end">
                            {reservaSeleccionada.estado}
                          </IonChip>
                        </IonItem>
                      </IonCol>
                    </IonRow>
                    
                    {reservaSeleccionada.estado !== 'cancelada' && (
                      <IonRow>
                        <IonCol size="12" className="ion-padding-top">
                        <IonButton 
                          expand="block" 
                          color="danger"
                          onClick={() => cancelarReserva(reservaSeleccionada.id)}
                        >
                          <IonIcon slot="start" icon={closeCircleOutline} />
                          Cancelar Reserva
                        </IonButton>
                        </IonCol>
                      </IonRow>
                    )}
                  </IonGrid>
                </IonCardContent>
              </IonCard>
            )}
          </IonContent>
        </IonModal>
        
        {/* Loading y Toast */}
        <IonLoading isOpen={cargando} message="Cargando reservas..." />
        
        <IonToast
          isOpen={mostrarToast}
          onDidDismiss={() => setMostrarToast(false)}
          message={mensajeToast}
          duration={2000}
          color={colorToast}
        />

        <IonAlert
          isOpen={showCancelConfirm}
          onDidDismiss={() => setShowCancelConfirm(false)}
          header="¿Cancelar reserva?"
          message="Esta acción no se puede deshacer"
          buttons={[
            {
              text: 'No',
              role: 'cancel',
              cssClass: 'secondary',
              handler: () => {
                setShowCancelConfirm(false);
                setReservaToCancel(null);
              }
            },
            {
              text: 'Sí',
              cssClass: 'danger',
              handler: confirmCancelReserva
            }
          ]}
        />


      </IonContent>
    </IonPage>
  );
};

export default CalendarView;
</file>

<file path="src/pages/Home.tsx">
// src/pages/Home.tsx
import React, { useState, useEffect } from 'react';
import { 
  IonContent, 
  IonHeader, 
  IonPage, 
  IonTitle, 
  IonToolbar, 
  IonButton, 
  IonCard, 
  IonCardContent, 
  IonCardHeader, 
  IonCardTitle, 
  IonGrid, 
  IonRow, 
  IonCol, 
  IonItem, 
  IonLabel, 
  IonText,
  IonIcon,
  IonButtons,
  IonLoading,
  IonList,
  IonRefresher,
  IonRefresherContent
} from '@ionic/react';
import { 
  logOutOutline, 
  personCircleOutline, 
  calendarOutline,
  businessOutline,
  addCircleOutline,
  tennisballOutline,
  peopleOutline,
  statsChartOutline,
  stopwatchOutline // Icono para el marcador
} from 'ionicons/icons';
import { useAuth } from '../context/AuthContext';
import { useHistory } from 'react-router-dom';
import apiService from '../services/api.service';
import './css/Home.css';

const Home: React.FC = () => {
  const { user, logout, isLoading } = useAuth();
  const [clubData, setClubData] = useState<any>(null);
  const [isLoadingClub, setIsLoadingClub] = useState<boolean>(false);
  const [pistaCount, setPistaCount] = useState<number>(0);
  const [reservasHoy, setReservasHoy] = useState<number>(0);
  const history = useHistory();
  
  // Determinar si el usuario es un administrador de club
  const isClubAdmin = user && user.id_rol === 1;

  // Función para cargar los datos del club (solo para administradores)
  const loadClubData = async (event?: CustomEvent) => {
    if (!user || !isClubAdmin) return;
    
    try {
      setIsLoadingClub(true);
      
      // 1. Obtener información del club filtrando por el administrador actual
      console.log(`Buscando club con id_administrador: ${user.id}`);
      const clubsResponse = await apiService.get(`/clubs?id_administrador=${user.id}`);
      
      console.log('Clubes encontrados:', clubsResponse);
      
      if (clubsResponse && Array.isArray(clubsResponse) && clubsResponse.length > 0) {
        // Usar el club asociado a este administrador (no simplemente el primero)
        const club = clubsResponse.find(c => c.id_administrador === user.id) || clubsResponse[0];
        setClubData(club);
        
        console.log('Club cargado:', club);
        
        // 2. Obtener el número de pistas del club
        const pistasResponse = await apiService.get(`/clubs/${club.id}/pistas`);
        if (Array.isArray(pistasResponse)) {
          setPistaCount(pistasResponse.length);
        }
        
        // 3. Obtener reservas para hoy
        const today = new Date().toISOString().split('T')[0]; // formato YYYY-MM-DD
        const reservasResponse = await apiService.get(`/reservas?id_club=${club.id}&fecha=${today}`);
        if (Array.isArray(reservasResponse)) {
          setReservasHoy(reservasResponse.length);
        }
      } else {
        console.log('No se encontraron clubes para este administrador');
        setClubData(null);
      }
    } catch (error) {
      console.error('Error al cargar datos del club:', error);
    } finally {
      setIsLoadingClub(false);
      if (event) event.detail.complete(); // Completar el refresher si existe
    }
  };

  // Cargar datos del club cuando el componente se monta (solo para administradores)
  useEffect(() => {
    if (isClubAdmin) {
      loadClubData();
    }
  }, [user, isClubAdmin]);

  const handleLogout = async () => {
    await logout();
    history.replace('/login');
  };

  const goToProfile = () => {
    history.push('/profile');
  };

  const goToReservas = () => {
    history.push('/reservas');
  };
  
  const goToManageCourts = () => {
    history.push('/manage-courts');
  };

  // Añadimos la función para ir a la vista de calendario
  const goToCalendar = () => {
    history.push('/calendar');
  };

  // Función para ir a la página de gestión de usuarios
  const goToManageUsers = () => {
    history.push('/manage-users');
  };

  // Nueva función para ir al marcador
  const goToScoreboard = () => {
    history.push('/marcador-control');
  };

  // Vista para administradores de club
  const renderClubAdminView = () => {
    return (
      <IonGrid>
        <IonRow className="ion-justify-content-center">
          <IonCol size="12" sizeMd="8" sizeLg="6">
            <IonCard className="welcome-card">
              <IonCardHeader className="welcome-card-header">
                <IonCardTitle>Panel de Administración</IonCardTitle>
              </IonCardHeader>
              <IonCardContent className="welcome-card-content">
                {clubData ? (
                  <>
                    <div className="club-info">
                      <IonItem lines="none" className="club-header">
                        <IonIcon icon={businessOutline} slot="start" size="large" color="primary"></IonIcon>
                        <IonLabel>
                          <h2>{clubData.nombre}</h2>
                          <IonText color="medium">
                            <p>{clubData.direccion}</p>
                          </IonText>
                        </IonLabel>
                      </IonItem>
                      
                      <div className="club-stats">
                        <IonRow>
                          <IonCol size="6">
                            <div className="stat-card">
                              <IonIcon icon={tennisballOutline} color="primary"></IonIcon>
                              <h3>{pistaCount}</h3>
                              <p>Pistas</p>
                            </div>
                          </IonCol>
                          <IonCol size="6">
                            <div className="stat-card">
                              <IonIcon icon={calendarOutline} color="success"></IonIcon>
                              <h3>{reservasHoy}</h3>
                              <p>Reservas Hoy</p>
                            </div>
                          </IonCol>
                        </IonRow>
                      </div>
                      
                      <h4 className="section-title">Gestión del Club</h4>
                      <IonList>
                        <IonItem button onClick={goToManageCourts} detail>
                          <IonIcon icon={tennisballOutline} slot="start" color="primary"></IonIcon>
                          <IonLabel>Gestionar Pistas</IonLabel>
                          <IonText slot="end" color="medium">{pistaCount}</IonText>
                        </IonItem>
                        <IonItem button onClick={goToCalendar} detail>
                          <IonIcon icon={calendarOutline} slot="start" color="secondary"></IonIcon>
                          <IonLabel>Reservas y Calendario</IonLabel>
                        </IonItem>
                        <IonItem button onClick={goToManageUsers} detail>
                          <IonIcon icon={peopleOutline} slot="start" color="tertiary"></IonIcon>
                          <IonLabel>Usuarios y Miembros</IonLabel>
                        </IonItem>
                        
                        {/* Nueva opción para el marcador */}
                        <IonItem button onClick={goToScoreboard} detail>
                          <IonIcon icon={stopwatchOutline} slot="start" color="warning"></IonIcon>
                          <IonLabel>Marcador de Partidos</IonLabel>
                        </IonItem>
                        
                        <IonItem button detail>
                          <IonIcon icon={statsChartOutline} slot="start" color="success"></IonIcon>
                          <IonLabel>Estadísticas</IonLabel>
                        </IonItem>
                      </IonList>
                      
                    </div>
                  </>
                ) : (
                  <div className="no-club-data">
                    <IonText color="medium">
                      <p>No se ha encontrado información del club.</p>
                    </IonText>
                    <IonButton expand="block" color="primary">
                      <IonIcon slot="start" icon={businessOutline}></IonIcon>
                      Configurar Datos del Club
                    </IonButton>
                  </div>
                )}
              </IonCardContent>
            </IonCard>
          </IonCol>
        </IonRow>
      </IonGrid>
    );
  };

  // Vista para usuarios normales
  const renderUserView = () => {
    return (
      <IonGrid>
        <IonRow className="ion-justify-content-center">
          <IonCol size="12" sizeMd="8" sizeLg="6">
            <IonCard className="welcome-card">
              <IonCardHeader className="welcome-card-header">
                <IonCardTitle>¡Bienvenido a Play4Padel!</IonCardTitle>
              </IonCardHeader>
              <IonCardContent className="welcome-card-content">
                {user && (
                  <div className="user-info">
                    {/* Se elimina el button y onClick aquí */}
                    <IonItem lines="none">
                      <IonIcon icon={personCircleOutline} slot="start" size="large" color="primary"></IonIcon>
                      <IonLabel>
                        <h2>Hola, {user.nombre} {user.apellidos}</h2>
                        <IonText color="medium">
                          <p>{user.email}</p>
                        </IonText>
                      </IonLabel>
                    </IonItem>
                    
                    <p className="ion-padding-top">
                      Ya has iniciado sesión correctamente en la plataforma. Desde aquí podrás:
                    </p>
                    <ul>
                      <li>Buscar clubes de pádel</li>
                      <li>Reservar pistas</li>
                      <li>Participar en torneos</li>
                      <li>Gestionar tu perfil y preferencias</li>
                    </ul>
                  </div>
                )}
                
                <IonButton expand="block" color="primary" onClick={goToReservas}>
                  <IonIcon slot="start" icon={calendarOutline}></IonIcon>
                  Reservar Pista
                </IonButton>
              </IonCardContent>
            </IonCard>
          </IonCol>
        </IonRow>
      </IonGrid>
    );
  };

  return (
    <IonPage>
      <IonHeader>
        <IonToolbar className="home-toolbar">
          <IonTitle>
            {isClubAdmin && clubData ? clubData.nombre : 'Play4Padel - Inicio'}
          </IonTitle>
          <IonButtons slot="end">
            <IonButton onClick={goToProfile}>
              <IonIcon slot="icon-only" icon={personCircleOutline}></IonIcon>
            </IonButton>
            <IonButton onClick={handleLogout} className="logout-button">
              <IonIcon slot="start" icon={logOutOutline}></IonIcon>
              Cerrar Sesión
            </IonButton>
          </IonButtons>
        </IonToolbar>
      </IonHeader>
      <IonContent className="home-container">
        {isClubAdmin && (
          <IonRefresher slot="fixed" onIonRefresh={loadClubData}>
            <IonRefresherContent></IonRefresherContent>
          </IonRefresher>
        )}
        
        {isLoading || (isClubAdmin && isLoadingClub) ? (
          <IonLoading isOpen={true} message="Cargando..." />
        ) : (
          <>
            {isClubAdmin ? renderClubAdminView() : renderUserView()}
          </>
        )}
      </IonContent>
    </IonPage>
  );
};

export default Home;
</file>

</files>
